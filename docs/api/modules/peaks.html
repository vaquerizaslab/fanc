

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Peaks module &mdash; FAN-C 0.9.6-beta documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="FAN-C compatibility modules" href="compatibility.html" />
    <link rel="prev" title="Hic module" href="hic.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> FAN-C
          

          
          </a>

          
            
            
              <div class="version">
                0.9.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting started with FAN-C</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fanc.html">fanc: command line tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fancplot.html">fancplot: plotting from the command line</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">Python API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../quickstart.html">Quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="../compatibility.html">Working with Juicer and Cooler files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interfaces.html">Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generate.html">Generate Hi-C matrices (API)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analyse.html">Analyse Hi-C matrices (API)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plot.html">Plotting (API)</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../modules.html">Reference</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="init.html">init</a></li>
<li class="toctree-l3"><a class="reference internal" href="map.html">map</a></li>
<li class="toctree-l3"><a class="reference internal" href="regions.html">regions</a></li>
<li class="toctree-l3"><a class="reference internal" href="pairs.html">pairs</a></li>
<li class="toctree-l3"><a class="reference internal" href="matrix.html">matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="hic.html">hic</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">peaks</a></li>
<li class="toctree-l3"><a class="reference internal" href="compatibility.html">compatibility</a></li>
<li class="toctree-l3"><a class="reference internal" href="architecture.html">architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="plotting.html">plotting</a></li>
<li class="toctree-l3"><a class="reference internal" href="tools.html">tools</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">FAN-C</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../api.html">fanc Python module</a> &raquo;</li>
        
          <li><a href="../modules.html">FAN-C Python modules</a> &raquo;</li>
        
      <li>Peaks module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/api/modules/peaks.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-fanc.peaks">
<span id="peaks-module"></span><h1>Peaks module<a class="headerlink" href="#module-fanc.peaks" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="fanc.peaks.DistancePeakFilter">
<em class="property">class </em><code class="sig-prename descclassname">fanc.peaks.</code><code class="sig-name descname">DistancePeakFilter</code><span class="sig-paren">(</span><em class="sig-param">cutoff=1</em>, <em class="sig-param">mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.DistancePeakFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fanc.peaks.PeakFilter" title="fanc.peaks.PeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">fanc.peaks.PeakFilter</span></code></a></p>
<p>Filter for peaks where regions are closer than this cutoff in bins.</p>
<dl class="method">
<dt id="fanc.peaks.DistancePeakFilter.valid">
<code class="sig-name descname">valid</code><span class="sig-paren">(</span><em class="sig-param">row</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.DistancePeakFilter.valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Map valid_peak to MaskFilter.valid(self, row).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>row</strong> – A pytables Table row.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The boolean value returned by valid_edge.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.DistancePeakFilter.valid_peak">
<code class="sig-name descname">valid_peak</code><span class="sig-paren">(</span><em class="sig-param">peak</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.DistancePeakFilter.valid_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate whether a peak passes FDR cutoffs set in __init__
:param peak: An <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code> object
:return: True if peak passes internal FDR cutoffs, False otherwise</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="fanc.peaks.EnrichmentPeakFilter">
<em class="property">class </em><code class="sig-prename descclassname">fanc.peaks.</code><code class="sig-name descname">EnrichmentPeakFilter</code><span class="sig-paren">(</span><em class="sig-param">enrichment_cutoff=None</em>, <em class="sig-param">enrichment_ll_cutoff=None</em>, <em class="sig-param">enrichment_h_cutoff=None</em>, <em class="sig-param">enrichment_v_cutoff=None</em>, <em class="sig-param">enrichment_d_cutoff=None</em>, <em class="sig-param">mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.EnrichmentPeakFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fanc.peaks.PeakFilter" title="fanc.peaks.PeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">fanc.peaks.PeakFilter</span></code></a></p>
<p>Filter peaks that do not have a sufficiently strong observed/expected ratio.</p>
<dl class="method">
<dt id="fanc.peaks.EnrichmentPeakFilter.valid">
<code class="sig-name descname">valid</code><span class="sig-paren">(</span><em class="sig-param">row</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.EnrichmentPeakFilter.valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Map valid_peak to MaskFilter.valid(self, row).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>row</strong> – A pytables Table row.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The boolean value returned by valid_edge.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.EnrichmentPeakFilter.valid_peak">
<code class="sig-name descname">valid_peak</code><span class="sig-paren">(</span><em class="sig-param">peak</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.EnrichmentPeakFilter.valid_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a <code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeak</span></code> object is valid or should
be filtered.</p>
<p>When implementing custom PeakFilter this method must be
overridden. It should return False for <code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeak</span></code> objects that
are to be fitered and True otherwise.</p>
<p>Internally, the <a class="reference internal" href="#fanc.peaks.RaoPeakInfo" title="fanc.peaks.RaoPeakInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeakInfo</span></code></a> object will iterate over all RaoPeak
instances to determine their validity on an individual
basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>peak</strong> – A <code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeak</span></code> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <a class="reference internal" href="#fanc.peaks.PeakFilter" title="fanc.peaks.PeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">PeakFilter</span></code></a> is valid, False otherwise</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="fanc.peaks.FdrPeakFilter">
<em class="property">class </em><code class="sig-prename descclassname">fanc.peaks.</code><code class="sig-name descname">FdrPeakFilter</code><span class="sig-paren">(</span><em class="sig-param">mask=None</em>, <em class="sig-param">fdr_cutoff=None</em>, <em class="sig-param">fdr_ll_cutoff=None</em>, <em class="sig-param">fdr_v_cutoff=None</em>, <em class="sig-param">fdr_h_cutoff=None</em>, <em class="sig-param">fdr_d_cutoff=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.FdrPeakFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fanc.peaks.PeakFilter" title="fanc.peaks.PeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">fanc.peaks.PeakFilter</span></code></a></p>
<p>Filter for peaks that do not pass a certain FDR cutoff.</p>
<dl class="method">
<dt id="fanc.peaks.FdrPeakFilter.valid">
<code class="sig-name descname">valid</code><span class="sig-paren">(</span><em class="sig-param">row</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.FdrPeakFilter.valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Map valid_peak to MaskFilter.valid(self, row).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>row</strong> – A pytables Table row.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The boolean value returned by valid_edge.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.FdrPeakFilter.valid_peak">
<code class="sig-name descname">valid_peak</code><span class="sig-paren">(</span><em class="sig-param">peak</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.FdrPeakFilter.valid_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate whether a peak passes FDR cutoffs set in __init__
:param peak: An <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code> object
:return: True if peak passes interal FDR cutoffs, False otherwise</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="fanc.peaks.FdrSumFilter">
<em class="property">class </em><code class="sig-prename descclassname">fanc.peaks.</code><code class="sig-name descname">FdrSumFilter</code><span class="sig-paren">(</span><em class="sig-param">cutoff=1.0</em>, <em class="sig-param">mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.FdrSumFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fanc.peaks.PeakFilter" title="fanc.peaks.PeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">fanc.peaks.PeakFilter</span></code></a></p>
<p>Remove peaks that have a q-value sum &gt; cutoff.</p>
<dl class="method">
<dt id="fanc.peaks.FdrSumFilter.valid">
<code class="sig-name descname">valid</code><span class="sig-paren">(</span><em class="sig-param">row</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.FdrSumFilter.valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Map valid_peak to MaskFilter.valid(self, row).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>row</strong> – A pytables Table row.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The boolean value returned by valid_edge.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.FdrSumFilter.valid_peak">
<code class="sig-name descname">valid_peak</code><span class="sig-paren">(</span><em class="sig-param">peak</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.FdrSumFilter.valid_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a <code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeak</span></code> object is valid or should
be filtered.</p>
<p>When implementing custom PeakFilter this method must be
overridden. It should return False for <code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeak</span></code> objects that
are to be fitered and True otherwise.</p>
<p>Internally, the <a class="reference internal" href="#fanc.peaks.RaoPeakInfo" title="fanc.peaks.RaoPeakInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeakInfo</span></code></a> object will iterate over all RaoPeak
instances to determine their validity on an individual
basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>peak</strong> – A <code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeak</span></code> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <a class="reference internal" href="#fanc.peaks.PeakFilter" title="fanc.peaks.PeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">PeakFilter</span></code></a> is valid, False otherwise</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="fanc.peaks.LazyPeak">
<em class="property">class </em><code class="sig-prename descclassname">fanc.peaks.</code><code class="sig-name descname">LazyPeak</code><span class="sig-paren">(</span><em class="sig-param">row</em>, <em class="sig-param">nodes_table</em>, <em class="sig-param">bin_size=1</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.LazyPeak" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="matrix.html#fanc.matrix.LazyEdge" title="fanc.matrix.LazyEdge"><code class="xref py py-class docutils literal notranslate"><span class="pre">fanc.matrix.LazyEdge</span></code></a></p>
<p>Container for a Peak/enriched contact in a Hi-C matrix.</p>
<p>This class implements <a class="reference internal" href="#fanc.peaks.LazyPeak" title="fanc.peaks.LazyPeak"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyPeak</span></code></a>, which provides lazy
loading of attributes from a PyTables table row.</p>
</dd></dl>

<dl class="class">
<dt id="fanc.peaks.MappabilityPeakFilter">
<em class="property">class </em><code class="sig-prename descclassname">fanc.peaks.</code><code class="sig-name descname">MappabilityPeakFilter</code><span class="sig-paren">(</span><em class="sig-param">mask=None</em>, <em class="sig-param">mappability_cutoff=None</em>, <em class="sig-param">mappability_ll_cutoff=None</em>, <em class="sig-param">mappability_v_cutoff=None</em>, <em class="sig-param">mappability_h_cutoff=None</em>, <em class="sig-param">mappability_d_cutoff=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.MappabilityPeakFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fanc.peaks.PeakFilter" title="fanc.peaks.PeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">fanc.peaks.PeakFilter</span></code></a></p>
<p>Filter for peaks that do not pass a certain FDR cutoff.</p>
<dl class="method">
<dt id="fanc.peaks.MappabilityPeakFilter.valid">
<code class="sig-name descname">valid</code><span class="sig-paren">(</span><em class="sig-param">row</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.MappabilityPeakFilter.valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Map valid_peak to MaskFilter.valid(self, row).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>row</strong> – A pytables Table row.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The boolean value returned by valid_edge.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.MappabilityPeakFilter.valid_peak">
<code class="sig-name descname">valid_peak</code><span class="sig-paren">(</span><em class="sig-param">peak</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.MappabilityPeakFilter.valid_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate whether a peak passes FDR cutoffs set in __init__
:param peak: An <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code> object
:return: True if peak passes interal FDR cutoffs, False otherwise</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="fanc.peaks.ObservedPeakFilter">
<em class="property">class </em><code class="sig-prename descclassname">fanc.peaks.</code><code class="sig-name descname">ObservedPeakFilter</code><span class="sig-paren">(</span><em class="sig-param">cutoff=1</em>, <em class="sig-param">mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.ObservedPeakFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fanc.peaks.PeakFilter" title="fanc.peaks.PeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">fanc.peaks.PeakFilter</span></code></a></p>
<p>Filter for peaks that do not pass a certain FDR cutoff.</p>
<dl class="method">
<dt id="fanc.peaks.ObservedPeakFilter.valid">
<code class="sig-name descname">valid</code><span class="sig-paren">(</span><em class="sig-param">row</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.ObservedPeakFilter.valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Map valid_peak to MaskFilter.valid(self, row).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>row</strong> – A pytables Table row.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The boolean value returned by valid_edge.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.ObservedPeakFilter.valid_peak">
<code class="sig-name descname">valid_peak</code><span class="sig-paren">(</span><em class="sig-param">peak</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.ObservedPeakFilter.valid_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate whether a peak passes FDR cutoffs set in __init__
:param peak: An <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code> object
:return: True if peak passes interal FDR cutoffs, False otherwise</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="fanc.peaks.Peak">
<em class="property">class </em><code class="sig-prename descclassname">fanc.peaks.</code><code class="sig-name descname">Peak</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">sink</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.Peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="matrix.html#fanc.matrix.Edge" title="fanc.matrix.Edge"><code class="xref py py-class docutils literal notranslate"><span class="pre">fanc.matrix.Edge</span></code></a></p>
<p>Container for a Peak/enriched contact in a Hi-C matrix.</p>
</dd></dl>

<dl class="class">
<dt id="fanc.peaks.PeakFilter">
<em class="property">class </em><code class="sig-prename descclassname">fanc.peaks.</code><code class="sig-name descname">PeakFilter</code><span class="sig-paren">(</span><em class="sig-param">mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">fanc.general.MaskFilter</span></code></p>
<p>Abstract class that provides filtering functionality for the
peaks in a <a class="reference internal" href="#fanc.peaks.RaoPeakInfo" title="fanc.peaks.RaoPeakInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeakInfo</span></code></a> object.</p>
<p>Extends MaskFilter and overrides valid(self, row) to make
<a class="reference internal" href="#fanc.peaks.RaoPeakInfo" title="fanc.peaks.RaoPeakInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeakInfo</span></code></a> filtering more “natural”.</p>
<p>To create custom filters for the <code class="xref py py-class docutils literal notranslate"><span class="pre">RapPeakInfo</span></code> object, extend this
class and override the valid_peak(self, peak) method.
valid_peak should return False for a specific <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code> object
if the object is supposed to be filtered/masked and True
otherwise. See <code class="xref py py-class docutils literal notranslate"><span class="pre">DiagonalFilter</span></code> for an example.</p>
<p>Pass a custom filter to the <a class="reference internal" href="#fanc.peaks.RaoPeakInfo.filter" title="fanc.peaks.RaoPeakInfo.filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a> method in <code class="xref py py-class docutils literal notranslate"><span class="pre">Hic</span></code>
to apply it.</p>
<dl class="method">
<dt id="fanc.peaks.PeakFilter.valid">
<code class="sig-name descname">valid</code><span class="sig-paren">(</span><em class="sig-param">row</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakFilter.valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Map valid_peak to MaskFilter.valid(self, row).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>row</strong> – A pytables Table row.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The boolean value returned by valid_edge.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakFilter.valid_peak">
<em class="property">abstract </em><code class="sig-name descname">valid_peak</code><span class="sig-paren">(</span><em class="sig-param">peak</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakFilter.valid_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a <code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeak</span></code> object is valid or should
be filtered.</p>
<p>When implementing custom PeakFilter this method must be
overridden. It should return False for <code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeak</span></code> objects that
are to be fitered and True otherwise.</p>
<p>Internally, the <a class="reference internal" href="#fanc.peaks.RaoPeakInfo" title="fanc.peaks.RaoPeakInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeakInfo</span></code></a> object will iterate over all RaoPeak
instances to determine their validity on an individual
basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>peak</strong> – A <code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeak</span></code> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <a class="reference internal" href="#fanc.peaks.PeakFilter" title="fanc.peaks.PeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">PeakFilter</span></code></a> is valid, False otherwise</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="fanc.peaks.PeakInfo">
<em class="property">class </em><code class="sig-prename descclassname">fanc.peaks.</code><code class="sig-name descname">PeakInfo</code><span class="sig-paren">(</span><em class="sig-param">file_name=None</em>, <em class="sig-param">mode='a'</em>, <em class="sig-param">tmpdir=None</em>, <em class="sig-param">_table_name_regions='regions'</em>, <em class="sig-param">_table_name_peaks='edges'</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="matrix.html#fanc.matrix.RegionMatrixTable" title="fanc.matrix.RegionMatrixTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">fanc.matrix.RegionMatrixTable</span></code></a></p>
<p>General-purpose class for recording peaks in Hic (and similar) data.</p>
<p>A peak has the following information:
source, sink: coordinates of the highest peak pixel in the Hi-C matrix
observed: observed value of the peak in the Hi-C matrix, generally uncorrected
expected: expected value of the peak at this position in the Hi-C matrix
p_value: a P-value that reflects how likely it is to observe a peak with
these properties at random
x, y: coordinates of the peak centroid, if it is larger than one pixel
radius: radius of the peak, expressed in bins (can be converted to base pairs)</p>
<dl class="class">
<dt id="fanc.peaks.PeakInfo.ChromosomeDescription">
<em class="property">class </em><code class="sig-name descname">ChromosomeDescription</code><a class="headerlink" href="#fanc.peaks.PeakInfo.ChromosomeDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tables.description.IsDescription</span></code></p>
<p>Description of the chromosomes in this object.</p>
</dd></dl>

<dl class="class">
<dt id="fanc.peaks.PeakInfo.MaskDescription">
<em class="property">class </em><code class="sig-name descname">MaskDescription</code><a class="headerlink" href="#fanc.peaks.PeakInfo.MaskDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tables.description.IsDescription</span></code></p>
</dd></dl>

<dl class="class">
<dt id="fanc.peaks.PeakInfo.RegionDescription">
<em class="property">class </em><code class="sig-name descname">RegionDescription</code><a class="headerlink" href="#fanc.peaks.PeakInfo.RegionDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tables.description.IsDescription</span></code></p>
<p>Description of a genomic region for PyTables Table</p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.add_contact">
<code class="sig-name descname">add_contact</code><span class="sig-paren">(</span><em class="sig-param">contact</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.add_contact" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">add_edge()</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>contact</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code></p></li>
<li><p><strong>args</strong> – Positional arguments passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">_add_edge()</span></code></p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">_add_edge()</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.add_contacts">
<code class="sig-name descname">add_contacts</code><span class="sig-paren">(</span><em class="sig-param">contacts</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.add_contacts" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">add_edges()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.add_edge">
<code class="sig-name descname">add_edge</code><span class="sig-paren">(</span><em class="sig-param">edge</em>, <em class="sig-param">check_nodes_exist=True</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.add_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an edge / contact between two regions to this object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>edge</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code>, dict with at least the
attributes source and sink, optionally weight,
or a list of length 2 (source, sink) or 3
(source, sink, weight).</p></li>
<li><p><strong>check_nodes_exist</strong> – Make sure that there are nodes
that match source and sink indexes</p></li>
<li><p><strong>args</strong> – Positional arguments passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">_add_edge()</span></code></p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">_add_edge()</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.add_edge_from_dict">
<code class="sig-name descname">add_edge_from_dict</code><span class="sig-paren">(</span><em class="sig-param">edge</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.add_edge_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct method to add an edge from dict input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge</strong> – dict with at least the keys “source”
and “sink”. Additional keys will be loaded
as edge attributes</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.add_edge_from_edge">
<code class="sig-name descname">add_edge_from_edge</code><span class="sig-paren">(</span><em class="sig-param">edge</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.add_edge_from_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct method to add an edge from <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code> input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.add_edge_from_list">
<code class="sig-name descname">add_edge_from_list</code><span class="sig-paren">(</span><em class="sig-param">edge</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.add_edge_from_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct method to add an edge from list or tuple input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge</strong> – List or tuple. Should be of length 2
(source, sink) or 3 (source, sink, weight)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.add_edge_simple">
<code class="sig-name descname">add_edge_simple</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">sink</em>, <em class="sig-param">weight=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.add_edge_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct method to add an edge from <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code> input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source</strong> – Source region index</p></li>
<li><p><strong>sink</strong> – Sink region index</p></li>
<li><p><strong>weight</strong> – Weight of the edge</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.add_edges">
<code class="sig-name descname">add_edges</code><span class="sig-paren">(</span><em class="sig-param">edges</em>, <em class="sig-param">flush=True</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.add_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Bulk-add edges from a list.</p>
<p>List items can be any of the supported edge types,
list, tuple, dict, or <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code>. Repeatedly
calls <code class="xref py py-func docutils literal notranslate"><span class="pre">add_edge()</span></code>, so
may be inefficient for large amounts of data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edges</strong> – List (or iterator) of edges. See
<code class="xref py py-func docutils literal notranslate"><span class="pre">add_edge()</span></code>
for details</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.add_mask_description">
<code class="sig-name descname">add_mask_description</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">description</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.add_mask_description" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a mask description to the _mask table and return its ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – name of the mask</p></li>
<li><p><strong>description</strong> (<em>str</em>) – description of the mask</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>id of the mask</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.add_region">
<code class="sig-name descname">add_region</code><span class="sig-paren">(</span><em class="sig-param">region</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.add_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a genomic region to this object.</p>
<p>This method offers some flexibility in the types of objects
that can be loaded. See parameters for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>region</strong> – Can be a <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code>, a str in the form
‘&lt;chromosome&gt;:&lt;start&gt;-&lt;end&gt;[:&lt;strand&gt;], a dict with
at least the fields ‘chromosome’, ‘start’, and
‘end’, optionally ‘ix’, or a list of length 3
(chromosome, start, end) or 4 (ix, chromosome,
start, end).</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.add_regions">
<code class="sig-name descname">add_regions</code><span class="sig-paren">(</span><em class="sig-param">regions</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.add_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bulk insert multiple genomic regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>regions</strong> – List (or any iterator) with objects that
describe a genomic region. See
<code class="xref py py-class docutils literal notranslate"><span class="pre">add_region</span></code> for options.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.bin_intervals">
<em class="property">static </em><code class="sig-name descname">bin_intervals</code><span class="sig-paren">(</span><em class="sig-param">intervals</em>, <em class="sig-param">bins</em>, <em class="sig-param">interval_range=None</em>, <em class="sig-param">smoothing_window=None</em>, <em class="sig-param">nan_replacement=None</em>, <em class="sig-param">zero_to_nan=False</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.bin_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Bin a given set of intervals into a fixed number of bins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>intervals</strong> – iterator of tuples (start, end, score)</p></li>
<li><p><strong>bins</strong> – Number of bins to divide the region into</p></li>
<li><p><strong>interval_range</strong> – Optional. Tuple (start, end) in base pairs
of range of interval to be binned. Useful if
intervals argument does not cover to exact
genomic range to be binned.</p></li>
<li><p><strong>smoothing_window</strong> – Size of window (in bins) to smooth scores
over</p></li>
<li><p><strong>nan_replacement</strong> – NaN values in the scores will be replaced
with this value</p></li>
<li><p><strong>zero_to_nan</strong> – If True, will convert bins with score 0 to NaN</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>iterator of tuples: (start, end, score)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.bin_intervals_equidistant">
<em class="property">static </em><code class="sig-name descname">bin_intervals_equidistant</code><span class="sig-paren">(</span><em class="sig-param">intervals</em>, <em class="sig-param">bin_size</em>, <em class="sig-param">interval_range=None</em>, <em class="sig-param">smoothing_window=None</em>, <em class="sig-param">nan_replacement=None</em>, <em class="sig-param">zero_to_nan=False</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.bin_intervals_equidistant" title="Permalink to this definition">¶</a></dt>
<dd><p>Bin a given set of intervals into bins with a fixed size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>intervals</strong> – iterator of tuples (start, end, score)</p></li>
<li><p><strong>bin_size</strong> – Size of each bin in base pairs</p></li>
<li><p><strong>interval_range</strong> – Optional. Tuple (start, end) in base pairs
of range of interval to be binned. Useful if
intervals argument does not cover to exact
genomic range to be binned.</p></li>
<li><p><strong>smoothing_window</strong> – Size of window (in bins) to smooth scores
over</p></li>
<li><p><strong>nan_replacement</strong> – NaN values in the scores will be replaced
with this value</p></li>
<li><p><strong>zero_to_nan</strong> – If True, will convert bins with score 0 to NaN</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>iterator of tuples: (start, end, score)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.bin_size">
<em class="property">property </em><code class="sig-name descname">bin_size</code><a class="headerlink" href="#fanc.peaks.PeakInfo.bin_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the first region in the dataset.</p>
<p>Assumes all bins have equal size.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.binned_regions">
<code class="sig-name descname">binned_regions</code><span class="sig-paren">(</span><em class="sig-param">region=None</em>, <em class="sig-param">bins=None</em>, <em class="sig-param">bin_size=None</em>, <em class="sig-param">smoothing_window=None</em>, <em class="sig-param">nan_replacement=None</em>, <em class="sig-param">zero_to_nan=False</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.binned_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as region_intervals, but returns <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code>
objects instead of tuples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>region</strong> – String or class:<cite>~GenomicRegion</cite>
object denoting the region to be binned</p></li>
<li><p><strong>bins</strong> – Number of bins to divide the region into</p></li>
<li><p><strong>bin_size</strong> – Size of each bin (alternative to bins argument)</p></li>
<li><p><strong>smoothing_window</strong> – Size of window (in bins) to smooth scores
over</p></li>
<li><p><strong>nan_replacement</strong> – NaN values in the scores will be replaced
with this value</p></li>
<li><p><strong>zero_to_nan</strong> – If True, will convert bins with score 0 to NaN</p></li>
<li><p><strong>args</strong> – Arguments passed to _region_intervals</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to _region_intervals</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>iterator of <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code> objects</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.bins_to_distance">
<code class="sig-name descname">bins_to_distance</code><span class="sig-paren">(</span><em class="sig-param">bins</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.bins_to_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert fraction of bins to base pairs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>bins</strong> – float, fraction of bins</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>int, base pairs</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.chromosome_bins">
<em class="property">property </em><code class="sig-name descname">chromosome_bins</code><a class="headerlink" href="#fanc.peaks.PeakInfo.chromosome_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of chromosomes and the start
and end index of the bins they cover.</p>
<p>Returned list is range-compatible, i.e. chromosome
bins [0,5] cover chromosomes 1, 2, 3, and 4, not 5.</p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.chromosome_lengths">
<em class="property">property </em><code class="sig-name descname">chromosome_lengths</code><a class="headerlink" href="#fanc.peaks.PeakInfo.chromosome_lengths" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of chromosomes and their length
in bp.</p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.chromosomes">
<code class="sig-name descname">chromosomes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.chromosomes" title="Permalink to this definition">¶</a></dt>
<dd><p>List all chromosomes in this regions table.
:return: list of chromosome names.</p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><em class="sig-param">copy_tmp=True</em>, <em class="sig-param">remove_tmp=True</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close this HDF5 file and run exit operations.</p>
<p>If file was opened with tmpdir in read-only mode:
close file and delete temporary copy.</p>
<p>If file was opened with tmpdir in write or append mode:
Replace original file with copy and delete copy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>copy_tmp</strong> – If False, does not overwrite original with modified file.</p></li>
<li><p><strong>remove_tmp</strong> – If False, does not delete temporary copy of file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.distance_to_bins">
<code class="sig-name descname">distance_to_bins</code><span class="sig-paren">(</span><em class="sig-param">distance</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.distance_to_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert base pairs to fraction of bins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>distance</strong> – distance in base pairs</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>float, distance as fraction of bin size</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.downsample">
<code class="sig-name descname">downsample</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">file_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.downsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample edges from this object.</p>
<p>Sampling is always done on uncorrected Hi-C matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Sample size or reference object. If n &lt; 1 will be interpreted as
a fraction of total reads in this object.</p></li>
<li><p><strong>file_name</strong> – Output file name for down-sampled object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">RegionPairsTable</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.edge_data">
<code class="sig-name descname">edge_data</code><span class="sig-paren">(</span><em class="sig-param">attribute</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.edge_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over specific edge attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attribute</strong> – Name of the attribute, e.g. “weight”</p></li>
<li><p><strong>args</strong> – Positional arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>iterator over edge attribute</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.edge_subset">
<code class="sig-name descname">edge_subset</code><span class="sig-paren">(</span><em class="sig-param">key=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.edge_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a subset of edges.</p>
<p>This is an alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>generator (<code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.edges">
<em class="property">property </em><code class="sig-name descname">edges</code><a class="headerlink" href="#fanc.peaks.PeakInfo.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over contacts / edges.</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code> is the central function of
<code class="xref py py-class docutils literal notranslate"><span class="pre">RegionPairsContainer</span></code>. Here, we will use the
<code class="xref py py-class docutils literal notranslate"><span class="pre">Hic</span></code> implementation for demonstration purposes,
but the usage is exactly the same for all compatible
objects implementing <code class="xref py py-class docutils literal notranslate"><span class="pre">RegionPairsContainer</span></code>, including
<a class="reference internal" href="compatibility/juicer.html#fanc.compatibility.juicer.JuicerHic" title="fanc.compatibility.juicer.JuicerHic"><code class="xref py py-class docutils literal notranslate"><span class="pre">JuicerHic</span></code></a> and
<a class="reference internal" href="compatibility/cooler.html#fanc.compatibility.cooler.CoolerHic" title="fanc.compatibility.cooler.CoolerHic"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoolerHic</span></code></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">fanc</span>

<span class="c1"># file from FAN-C examples</span>
<span class="n">hic</span> <span class="o">=</span> <span class="n">fanc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;output/hic/binned/fanc_example_1mb.hic&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>We can easily find the number of edges in the sample
<code class="xref py py-class docutils literal notranslate"><span class="pre">Hic</span></code> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>  <span class="c1"># 8695</span>
</pre></div>
</div>
<p>When used in an iterator context, <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code>
iterates over all edges in the <code class="xref py py-class docutils literal notranslate"><span class="pre">RegionPairsContainer</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
    <span class="c1"># do something with edge</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="c1"># 42--42; bias: 5.797788472650082e-05; sink_node: chr18:42000001-43000000; source_node: chr18:42000001-43000000; weight: 0.12291311562018173</span>
    <span class="c1"># 24--28; bias: 6.496381719803623e-05; sink_node: chr18:28000001-29000000; source_node: chr18:24000001-25000000; weight: 0.025205961072838057</span>
    <span class="c1"># 5--76; bias: 0.00010230955745211447; sink_node: chr18:76000001-77000000; source_node: chr18:5000001-6000000; weight: 0.00961709840049876</span>
    <span class="c1"># 66--68; bias: 8.248432587969082e-05; sink_node: chr18:68000001-69000000; source_node: chr18:66000001-67000000; weight: 0.03876763316345468</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>Calling <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code> as a method has the
same effect:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># note the &#39;()&#39;</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
    <span class="c1"># do something with edge</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="c1"># 42--42; bias: 5.797788472650082e-05; sink_node: chr18:42000001-43000000; source_node: chr18:42000001-43000000; weight: 0.12291311562018173</span>
    <span class="c1"># 24--28; bias: 6.496381719803623e-05; sink_node: chr18:28000001-29000000; source_node: chr18:24000001-25000000; weight: 0.025205961072838057</span>
    <span class="c1"># 5--76; bias: 0.00010230955745211447; sink_node: chr18:76000001-77000000; source_node: chr18:5000001-6000000; weight: 0.00961709840049876</span>
    <span class="c1"># 66--68; bias: 8.248432587969082e-05; sink_node: chr18:68000001-69000000; source_node: chr18:66000001-67000000; weight: 0.03876763316345468</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>Rather than iterate over all edges in the object, we can select only a subset.
If the key is a string or a <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code>, all non-zero edges connecting
the region described by the key to any other region are returned. If the key is a
tuple of strings or <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code>, only edges between the two regions
are returned.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># select all edges between chromosome 19</span>
<span class="c1"># and any other region:</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="s2">&quot;chr19&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="c1"># 49--106; bias: 0.00026372303696871666; sink_node: chr19:27000001-28000000; source_node: chr18:49000001-50000000; weight: 0.003692122517562033</span>
    <span class="c1"># 6--82; bias: 0.00021923129703834945; sink_node: chr19:3000001-4000000; source_node: chr18:6000001-7000000; weight: 0.0008769251881533978</span>
    <span class="c1"># 47--107; bias: 0.00012820949175399097; sink_node: chr19:28000001-29000000; source_node: chr18:47000001-48000000; weight: 0.0015385139010478917</span>
    <span class="c1"># 38--112; bias: 0.0001493344481069762; sink_node: chr19:33000001-34000000; source_node: chr18:38000001-39000000; weight: 0.0005973377924279048</span>
    <span class="c1"># ...</span>

<span class="c1"># select all edges that are only on</span>
<span class="c1"># chromosome 19</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">((</span><span class="s1">&#39;chr19&#39;</span><span class="p">,</span> <span class="s1">&#39;chr19&#39;</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="c1"># 90--116; bias: 0.00021173151730025176; sink_node: chr19:37000001-38000000; source_node: chr19:11000001-12000000; weight: 0.009104455243910825</span>
    <span class="c1"># 135--135; bias: 0.00018003890596887822; sink_node: chr19:56000001-57000000; source_node: chr19:56000001-57000000; weight: 0.10028167062466517</span>
    <span class="c1"># 123--123; bias: 0.00011063368998965993; sink_node: chr19:44000001-45000000; source_node: chr19:44000001-45000000; weight: 0.1386240135570439</span>
    <span class="c1"># 92--93; bias: 0.00040851066434864896; sink_node: chr19:14000001-15000000; source_node: chr19:13000001-14000000; weight: 0.10090213409411629</span>
    <span class="c1"># ...</span>

<span class="c1"># select inter-chromosomal edges</span>
<span class="c1"># between chromosomes 18 and 19</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">((</span><span class="s1">&#39;chr18&#39;</span><span class="p">,</span> <span class="s1">&#39;chr19&#39;</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="c1"># 49--106; bias: 0.00026372303696871666; sink_node: chr19:27000001-28000000; source_node: chr18:49000001-50000000; weight: 0.003692122517562033</span>
    <span class="c1"># 6--82; bias: 0.00021923129703834945; sink_node: chr19:3000001-4000000; source_node: chr18:6000001-7000000; weight: 0.0008769251881533978</span>
    <span class="c1"># 47--107; bias: 0.00012820949175399097; sink_node: chr19:28000001-29000000; source_node: chr18:47000001-48000000; weight: 0.0015385139010478917</span>
    <span class="c1"># 38--112; bias: 0.0001493344481069762; sink_node: chr19:33000001-34000000; source_node: chr18:38000001-39000000; weight: 0.0005973377924279048</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>By default, <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code> will retrieve all edge attributes,
which can be slow when iterating over a lot of edges. This is why all file-based FAN-C
<code class="xref py py-class docutils literal notranslate"><span class="pre">RegionPairsContainer</span></code> objects support lazy loading, where attributes
are only read on demand.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="s1">&#39;chr18&#39;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">sink</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
    <span class="c1"># 42 42 0.12291311562018173 &lt;fanc.matrix.LazyEdge for row /edges/chrpair_0_0.row (Row), pointing to row #0&gt;</span>
    <span class="c1"># 24 28 0.025205961072838057 &lt;fanc.matrix.LazyEdge for row /edges/chrpair_0_0.row (Row), pointing to row #1&gt;</span>
    <span class="c1"># 5 76 0.00961709840049876 &lt;fanc.matrix.LazyEdge for row /edges/chrpair_0_0.row (Row), pointing to row #2&gt;</span>
    <span class="c1"># 66 68 0.03876763316345468 &lt;fanc.matrix.LazyEdge for row /edges/chrpair_0_0.row (Row), pointing to row #3&gt;</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The lazy iterator reuses the <code class="xref py py-class docutils literal notranslate"><span class="pre">LazyEdge</span></code> object in every iteration,
and overwrites the <code class="xref py py-class docutils literal notranslate"><span class="pre">LazyEdge</span></code> attributes. Therefore <strong>do not</strong> use
lazy iterators if you need to store edge objects for later access.
For example, the following code works as expected
<code class="code docutils literal notranslate"><span class="pre">list(hic.edges())</span></code>, with all <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code> objects stored in the
list, while this code <code class="code docutils literal notranslate"><span class="pre">list(hic.edges(lazy=True))</span></code>
will result in a list of identical <code class="xref py py-class docutils literal notranslate"><span class="pre">LazyEdge</span></code> objects. Always ensure
you do all edge processing in the loop when working with lazy iterators!</p>
</div>
<p>When working with normalised contact frequencies, such as obtained through
matrix balancing in the example above, <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code>
automatically returns normalised edge weights. In addition, the <code class="code docutils literal notranslate"><span class="pre">bias</span></code>
attribute will (typically) have a value different from 1.</p>
<p>When you are interested in the raw contact frequency, use the <code class="code docutils literal notranslate"><span class="pre">norm=False</span></code>
parameter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="s1">&#39;chr18&#39;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">sink</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
    <span class="c1"># 42 42 2120.0</span>
    <span class="c1"># 24 28 388.0</span>
    <span class="c1"># 5 76 94.0</span>
    <span class="c1"># 66 68 470.0</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>You can also choose to omit all intra- or inter-chromosomal edges using
<code class="code docutils literal notranslate"><span class="pre">intra_chromosomal=False</span></code> or <code class="code docutils literal notranslate"><span class="pre">inter_chromosomal=False</span></code>, respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Iterator over <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code> or equivalent.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.edges_dict">
<code class="sig-name descname">edges_dict</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.edges_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Edges iterator with access by bracket notation.</p>
<p>This iterator <strong>always</strong> returns unnormalised edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dict or dict-like iterator</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.expected_values">
<code class="sig-name descname">expected_values</code><span class="sig-paren">(</span><em class="sig-param">selected_chromosome=None</em>, <em class="sig-param">norm=True</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.expected_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the expected values for genomic contacts at all distances.</p>
<p>This calculates the expected values between genomic regions
separated by a specific distance. Expected values are calculated
as the average weight of edges between region pairs with the same
genomic separation, taking into account unmappable regions.</p>
<p>It will return a tuple with three values: a list of genome-wide
intra-chromosomal expected values (list index corresponds to number
of separating bins), a dict with chromosome names as keys and
intra-chromosomal expected values specific to each chromosome, and
a float for inter-chromosomal expected value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>selected_chromosome</strong> – (optional) Chromosome name. If provided,
will only return expected values for this
chromosome.</p></li>
<li><p><strong>norm</strong> – If False, will calculate the expected values on the
unnormalised matrix.</p></li>
<li><p><strong>args</strong> – Not used in this context</p></li>
<li><p><strong>kwargs</strong> – Not used in this context</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of intra-chromosomal expected values,
dict of intra-chromosomal expected values by chromosome,
inter-chromosomal expected value</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.expected_values_and_marginals">
<code class="sig-name descname">expected_values_and_marginals</code><span class="sig-paren">(</span><em class="sig-param">selected_chromosome=None</em>, <em class="sig-param">norm=True</em>, <em class="sig-param">force=False</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.expected_values_and_marginals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the expected values for genomic contacts at all distances
and the whole matrix marginals.</p>
<p>This calculates the expected values between genomic regions
separated by a specific distance. Expected values are calculated
as the average weight of edges between region pairs with the same
genomic separation, taking into account unmappable regions.</p>
<p>It will return a tuple with three values: a list of genome-wide
intra-chromosomal expected values (list index corresponds to number
of separating bins), a dict with chromosome names as keys and
intra-chromosomal expected values specific to each chromosome, and
a float for inter-chromosomal expected value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>selected_chromosome</strong> – (optional) Chromosome name. If provided,
will only return expected values for this
chromosome.</p></li>
<li><p><strong>norm</strong> – If False, will calculate the expected values on the
unnormalised matrix.</p></li>
<li><p><strong>args</strong> – Not used in this context</p></li>
<li><p><strong>kwargs</strong> – Not used in this context</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of intra-chromosomal expected values,
dict of intra-chromosomal expected values by chromosome,
inter-chromosomal expected value</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.filter">
<code class="sig-name descname">filter</code><span class="sig-paren">(</span><em class="sig-param">edge_filter</em>, <em class="sig-param">queue=False</em>, <em class="sig-param">log_progress=True</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter edges in this object by using a
<code class="xref py py-class docutils literal notranslate"><span class="pre">MaskFilter</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>edge_filter</strong> – Class implementing <code class="xref py py-class docutils literal notranslate"><span class="pre">MaskFilter</span></code>.</p></li>
<li><p><strong>queue</strong> – If True, filter will be queued and can be executed
along with other queued filters using
<code class="xref py py-func docutils literal notranslate"><span class="pre">run_queued_filters()</span></code></p></li>
<li><p><strong>log_progress</strong> – If true, process iterating through all edges
will be continuously reported.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.filter_rao">
<code class="sig-name descname">filter_rao</code><span class="sig-paren">(</span><em class="sig-param">queue=False</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.filter_rao" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function that applies a <a class="reference internal" href="#fanc.peaks.RaoMergedPeakFilter" title="fanc.peaks.RaoMergedPeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">RaoMergedPeakFilter</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>queue</strong> – If True, filter will be queued and can be executed
along with other queued filters using
run_queued_filters</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.find_region">
<code class="sig-name descname">find_region</code><span class="sig-paren">(</span><em class="sig-param">query_regions</em>, <em class="sig-param">_regions_dict=None</em>, <em class="sig-param">_region_ends=None</em>, <em class="sig-param">_chromosomes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.find_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the region that is at the center of a region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>query_regions</strong> – Region selector string, :class:~GenomicRegion, or
list of the former</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>index (or list of indexes) of the region at the center of the
query region</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.flush">
<code class="sig-name descname">flush</code><span class="sig-paren">(</span><em class="sig-param">silent=False</em>, <em class="sig-param">update_mappability=True</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to file and flush buffers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>silent</strong> – do not print flush progress</p></li>
<li><p><strong>update_mappability</strong> – After writing data, update mappability and expected values</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.get_mask">
<code class="sig-name descname">get_mask</code><span class="sig-paren">(</span><em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.get_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Search _mask table for key and return Mask.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> (<em>int</em>) – search by mask name</p></li>
<li><p><strong>key</strong> – search by mask ID</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Mask</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.get_masks">
<code class="sig-name descname">get_masks</code><span class="sig-paren">(</span><em class="sig-param">ix</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.get_masks" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract mask IDs encoded in parameter and return masks.</p>
<p>IDs are powers of 2, so a single int field in the table can hold
multiple masks by simply adding up the IDs. Similar principle to
UNIX chmod (although that uses base 8)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ix</strong> (<em>int</em>) – integer that is the sum of powers of 2. Note that this value
is not necessarily itself a power of 2.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of Masks extracted from ix</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list (Mask)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.intervals">
<code class="sig-name descname">intervals</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for region_intervals.</p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.mappable">
<code class="sig-name descname">mappable</code><span class="sig-paren">(</span><em class="sig-param">region=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.mappable" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the mappability of regions in this object.</p>
<p>A “mappable” region has at least one contact to another region
in the genome.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">array</span></code> where True means mappable
and False unmappable</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.marginals">
<code class="sig-name descname">marginals</code><span class="sig-paren">(</span><em class="sig-param">masked=True</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.marginals" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the marginals vector of this Hic matrix.</p>
<p>Sums up all contacts for each bin of the Hi-C matrix.
Unmappable regoins will be masked in the returned vector unless
the <code class="code docutils literal notranslate"><span class="pre">masked</span></code> parameter is set to <code class="code docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>By default, corrected matrix entries are summed up.
To get uncorrected matrix marginals use <code class="code docutils literal notranslate"><span class="pre">norm=False</span></code>.
Generally, all parameters accepted by <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code>
are supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>masked</strong> – Use a numpy masked array to mask entries
corresponding to unmappable regions</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.matrix">
<code class="sig-name descname">matrix</code><span class="sig-paren">(</span><em class="sig-param">key=None</em>, <em class="sig-param">log=False</em>, <em class="sig-param">default_value=None</em>, <em class="sig-param">mask=True</em>, <em class="sig-param">log_base=2</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble a <code class="xref py py-class docutils literal notranslate"><span class="pre">RegionMatrix</span></code> from region pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> – Matrix selector. See <a class="reference internal" href="matrix.html#fanc.matrix.RegionPairsContainer.edges" title="fanc.matrix.RegionPairsContainer.edges"><code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></a>
for all supported key types</p></li>
<li><p><strong>log</strong> – If True, log-transform the matrix entries. Also see log_base</p></li>
<li><p><strong>log_base</strong> – Base of the log transformation. Default: 2; only used when
log=True</p></li>
<li><p><strong>default_value</strong> – (optional) set the default value of matrix entries
that have no associated edge/contact</p></li>
<li><p><strong>mask</strong> – If False, do not mask unmappable regions</p></li>
<li><p><strong>args</strong> – Positional arguments passed to
<a class="reference internal" href="matrix.html#fanc.matrix.RegionMatrixContainer.regions_and_matrix_entries" title="fanc.matrix.RegionMatrixContainer.regions_and_matrix_entries"><code class="xref py py-func docutils literal notranslate"><span class="pre">regions_and_matrix_entries()</span></code></a></p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to
<a class="reference internal" href="matrix.html#fanc.matrix.RegionMatrixContainer.regions_and_matrix_entries" title="fanc.matrix.RegionMatrixContainer.regions_and_matrix_entries"><code class="xref py py-func docutils literal notranslate"><span class="pre">regions_and_matrix_entries()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="matrix.html#fanc.matrix.RegionMatrix" title="fanc.matrix.RegionMatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegionMatrix</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.merge">
<em class="property">classmethod </em><code class="sig-name descname">merge</code><span class="sig-paren">(</span><em class="sig-param">matrices</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge multiple <code class="xref py py-class docutils literal notranslate"><span class="pre">RegionMatrixContainer</span></code> objects.</p>
<p>Merging is done by adding the weight of edges in each object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrices</strong> – list of <code class="xref py py-class docutils literal notranslate"><span class="pre">RegionMatrixContainer</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>merged <code class="xref py py-class docutils literal notranslate"><span class="pre">RegionMatrixContainer</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.possible_contacts">
<code class="sig-name descname">possible_contacts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.possible_contacts" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the possible number of contacts in the genome.</p>
<p>This calculates the number of potential region pairs in
a genome for any possible separation distance, taking into
account the existence of unmappable regions.</p>
<p>It will calculate one number for inter-chromosomal pairs,
return a list with the number of possible pairs where the
list index corresponds to the number of bins separating two regions,
and a dictionary of lists for each chromosome.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>possible intra-chromosomal pairs,
possible intra-chromosomal pairs by chromosome,
possible inter-chromosomal pairs</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.region_bins">
<code class="sig-name descname">region_bins</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.region_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>Return slice of start and end indices spanned by a region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>args</strong> – provide a <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code> here to get
the slice of start and end bins of onlythis region.
To get the slice over all regions leave this blank.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.region_data">
<code class="sig-name descname">region_data</code><span class="sig-paren">(</span><em class="sig-param">key</em>, <em class="sig-param">value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.region_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve or add vector-data to this object. If there is existing data in this
object with the same name, it will be replaced</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> – Name of the data column</p></li>
<li><p><strong>value</strong> – vector with region-based data (one entry per region)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.region_intervals">
<code class="sig-name descname">region_intervals</code><span class="sig-paren">(</span><em class="sig-param">region</em>, <em class="sig-param">bins=None</em>, <em class="sig-param">bin_size=None</em>, <em class="sig-param">smoothing_window=None</em>, <em class="sig-param">nan_replacement=None</em>, <em class="sig-param">zero_to_nan=False</em>, <em class="sig-param">score_field='score'</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.region_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return equally-sized genomic intervals and associated scores.</p>
<p>Use either bins or bin_size argument to control binning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>region</strong> – String or class:<cite>~GenomicRegion</cite>
object denoting the region to be binned</p></li>
<li><p><strong>bins</strong> – Number of bins to divide the region into</p></li>
<li><p><strong>bin_size</strong> – Size of each bin (alternative to bins argument)</p></li>
<li><p><strong>smoothing_window</strong> – Size of window (in bins) to smooth scores
over</p></li>
<li><p><strong>nan_replacement</strong> – NaN values in the scores will be replaced
with this value</p></li>
<li><p><strong>zero_to_nan</strong> – If True, will convert bins with score 0 to NaN</p></li>
<li><p><strong>args</strong> – Arguments passed to _region_intervals</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to _region_intervals</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>iterator of tuples: (start, end, score)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.region_subset">
<code class="sig-name descname">region_subset</code><span class="sig-paren">(</span><em class="sig-param">region</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.region_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a class:<cite>~GenomicRegion</cite> and returns all regions that
overlap with the supplied region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>region</strong> – String or class:<cite>~GenomicRegion</cite>
object for which covered bins will
be returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.regions">
<em class="property">property </em><code class="sig-name descname">regions</code><a class="headerlink" href="#fanc.peaks.PeakInfo.regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over genomic regions in this object.</p>
<p>Will return a <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code> object in every iteration.
Can also be used to get the number of regions by calling
len() on the object returned by this method.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>RegionIter</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.regions_and_edges">
<code class="sig-name descname">regions_and_edges</code><span class="sig-paren">(</span><em class="sig-param">key</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.regions_and_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenient access to regions and edges selected by key.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> – Edge selector, see <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
<li><p><strong>args</strong> – Positional arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of row regions, list of col regions, iterator over edges</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.regions_and_matrix_entries">
<code class="sig-name descname">regions_and_matrix_entries</code><span class="sig-paren">(</span><em class="sig-param">key=None</em>, <em class="sig-param">score_field=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.regions_and_matrix_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenient access to non-zero matrix entries and associated regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> – Edge key, see <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
<li><p><strong>oe</strong> – If True, will divide observed values by their expected value
at the given distance. False by default</p></li>
<li><p><strong>oe_per_chromosome</strong> – If True (default), will do a per-chromosome O/E
calculation rather than using the whole matrix
to obtain expected values</p></li>
<li><p><strong>score_field</strong> – (optional) any edge attribute that returns a number
can be specified here for filling the matrix. Usually
this is defined by the <code class="code docutils literal notranslate"><span class="pre">_default_score_field</span></code>
attribute of the matrix class.</p></li>
<li><p><strong>args</strong> – Positional arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of row regions, list of col regions, iterator over (i, j, weight) tuples</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.regions_dict">
<em class="property">property </em><code class="sig-name descname">regions_dict</code><a class="headerlink" href="#fanc.peaks.PeakInfo.regions_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary with region index as keys
and regions as values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dict {region.ix: region, …}</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.regions_identical">
<em class="property">static </em><code class="sig-name descname">regions_identical</code><span class="sig-paren">(</span><em class="sig-param">pairs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.regions_identical" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the regions in all objects in the list are identical.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pairs</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">RegionBased</span></code>
objects</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if chromosome, start, and end are identical between
all regions in the same list positions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.run_queued_filters">
<code class="sig-name descname">run_queued_filters</code><span class="sig-paren">(</span><em class="sig-param">log_progress=True</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.run_queued_filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Run queued filters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>log_progress</strong> – If true, process iterating through all edges
will be continuously reported.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.scaling_factor">
<code class="sig-name descname">scaling_factor</code><span class="sig-paren">(</span><em class="sig-param">matrix</em>, <em class="sig-param">weight_column=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.scaling_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the scaling factor to another matrix.</p>
<p>Calculates the ratio between the number of contacts in
this Hic object to the number of contacts in another
Hic object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> – A <code class="xref py py-class docutils literal notranslate"><span class="pre">Hic</span></code> object</p></li>
<li><p><strong>weight_column</strong> – Name of the column to calculate the scaling factor on</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.subset">
<code class="sig-name descname">subset</code><span class="sig-paren">(</span><em class="sig-param">*regions</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Subset a Hic object by specifying one or more subset regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>regions</strong> – string or GenomicRegion object(s)</p></li>
<li><p><strong>kwargs</strong> – Supports
file_name: destination file name of subset Hic object;
tmpdir: if True works in tmp until object is closed
additional parameters are passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Hic</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.to_bed">
<code class="sig-name descname">to_bed</code><span class="sig-paren">(</span><em class="sig-param">file_name</em>, <em class="sig-param">subset=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.to_bed" title="Permalink to this definition">¶</a></dt>
<dd><p>Export regions as BED file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> – Path of file to write regions to</p></li>
<li><p><strong>subset</strong> – optional <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code> or str to
write only regions overlapping this region</p></li>
<li><p><strong>kwargs</strong> – Passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">write_bed()</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.to_bigwig">
<code class="sig-name descname">to_bigwig</code><span class="sig-paren">(</span><em class="sig-param">file_name</em>, <em class="sig-param">subset=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.to_bigwig" title="Permalink to this definition">¶</a></dt>
<dd><p>Export regions as BigWig file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> – Path of file to write regions to</p></li>
<li><p><strong>subset</strong> – optional <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code> or str to
write only regions overlapping this region</p></li>
<li><p><strong>kwargs</strong> – Passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">write_bigwig()</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.PeakInfo.to_gff">
<code class="sig-name descname">to_gff</code><span class="sig-paren">(</span><em class="sig-param">file_name</em>, <em class="sig-param">subset=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.PeakInfo.to_gff" title="Permalink to this definition">¶</a></dt>
<dd><p>Export regions as GFF file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> – Path of file to write regions to</p></li>
<li><p><strong>subset</strong> – optional <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code> or str to
write only regions overlapping this region</p></li>
<li><p><strong>kwargs</strong> – Passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">write_gff()</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="fanc.peaks.RaoMergedPeakFilter">
<em class="property">class </em><code class="sig-prename descclassname">fanc.peaks.</code><code class="sig-name descname">RaoMergedPeakFilter</code><span class="sig-paren">(</span><em class="sig-param">cutoff=0.02</em>, <em class="sig-param">mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoMergedPeakFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fanc.peaks.PeakFilter" title="fanc.peaks.PeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">fanc.peaks.PeakFilter</span></code></a></p>
<p>Filter merged peaks exactly the same way that Rao et al. (2014) do.</p>
<p>It removes peaks that are singlets and have a q-value sum &gt;.02.</p>
<dl class="method">
<dt id="fanc.peaks.RaoMergedPeakFilter.valid">
<code class="sig-name descname">valid</code><span class="sig-paren">(</span><em class="sig-param">row</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoMergedPeakFilter.valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Map valid_peak to MaskFilter.valid(self, row).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>row</strong> – A pytables Table row.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The boolean value returned by valid_edge.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoMergedPeakFilter.valid_peak">
<code class="sig-name descname">valid_peak</code><span class="sig-paren">(</span><em class="sig-param">peak</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoMergedPeakFilter.valid_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a <code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeak</span></code> object is valid or should
be filtered.</p>
<p>When implementing custom PeakFilter this method must be
overridden. It should return False for <code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeak</span></code> objects that
are to be fitered and True otherwise.</p>
<p>Internally, the <a class="reference internal" href="#fanc.peaks.RaoPeakInfo" title="fanc.peaks.RaoPeakInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeakInfo</span></code></a> object will iterate over all RaoPeak
instances to determine their validity on an individual
basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>peak</strong> – A <code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeak</span></code> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <a class="reference internal" href="#fanc.peaks.PeakFilter" title="fanc.peaks.PeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">PeakFilter</span></code></a> is valid, False otherwise</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="fanc.peaks.RaoPeakCaller">
<em class="property">class </em><code class="sig-prename descclassname">fanc.peaks.</code><code class="sig-name descname">RaoPeakCaller</code><span class="sig-paren">(</span><em class="sig-param">p=None</em>, <em class="sig-param">w_init=None</em>, <em class="sig-param">min_locus_dist=None</em>, <em class="sig-param">max_w=20</em>, <em class="sig-param">min_ll_reads=16</em>, <em class="sig-param">process_inter=False</em>, <em class="sig-param">correct_inter='fdr'</em>, <em class="sig-param">n_processes=4</em>, <em class="sig-param">slice_size=2000</em>, <em class="sig-param">min_mappable_fraction=0.7</em>, <em class="sig-param">cluster=False</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakCaller" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class that calls peaks the same way Rao et al. (2014) propose.</p>
<p>Every pixel in a Hi-C matrix is evaluated based on its local
“neighborhood”, i.e. the pixel’s observed value is compared
to the expected value calculated from all pixels in its close
surroundings.</p>
<p>If a pixel is significantly enriched with respect to all
investigated neighborhoods, it is assumed to be a “peak”.</p>
<p>Four neighborhood types are calculated:</p>
<ul class="simple">
<li><p>“donut”: Pixels surrounding the investigated pixel in a
certain distance range</p></li>
<li><p>“lower-left” Pixels to the “lower-left” of a given pixel</p></li>
<li><p>“horizontal”: Pixels left and right of a given pixel</p></li>
<li><p>“vertical”: Pixels above and below a given pixel</p></li>
</ul>
<p>While the first neighborhood type most generally calculates
enrichment of local background, the other types of
neighborhoods serve mostly to exclude false-positive results
from non-peak structures, such as TAD boundaries.</p>
<p>The <a class="reference internal" href="#fanc.peaks.RaoPeakCaller" title="fanc.peaks.RaoPeakCaller"><code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeakCaller</span></code></a> is initialized with the peak
calling parameters and run using <a class="reference internal" href="#fanc.peaks.RaoPeakCaller.call_peaks" title="fanc.peaks.RaoPeakCaller.call_peaks"><code class="xref py py-func docutils literal notranslate"><span class="pre">call_peaks()</span></code></a>.</p>
<p>FDRs for intra-chromosomal peaks are automatically corrected for multiple
testing using the “lamda-chunking” methodology introduced in Rao et al. 2014.
FDRs for inter-chromosomal peaks are corrected by default using the Benjamini
Hochberg false-discovery rate correction (but ‘bonferroni’ is also an option)</p>
<dl class="method">
<dt id="fanc.peaks.RaoPeakCaller.call_peaks">
<code class="sig-name descname">call_peaks</code><span class="sig-paren">(</span><em class="sig-param">hic</em>, <em class="sig-param">chromosome_pairs=None</em>, <em class="sig-param">file_name=None</em>, <em class="sig-param">intra_expected=None</em>, <em class="sig-param">inter_expected=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakCaller.call_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Call peaks in Hi-C matrix.</p>
<p>This method will determine each pixel’s likelihood to
be a “true” peak. By default, only pixels with non-zero count and
an observed/expected ratio &gt; 1.0 for each neighborhood will be
reported, because these can by definition not be true peaks.</p>
<p>The peak calling behavior can be influenced by modifying
the object attributes set when initializing <a class="reference internal" href="#fanc.peaks.RaoPeakCaller" title="fanc.peaks.RaoPeakCaller"><code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeakCaller</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hic</strong> – A <code class="xref py py-class docutils literal notranslate"><span class="pre">Hic</span></code> object</p></li>
<li><p><strong>chromosome_pairs</strong> – If None, all chromosome pairs will be
investigated for peaks. Otherwise
specify a list of chromosome name
tuples (e.g. [(‘chr1’, ‘chr1’),
(‘chr1’, ‘chr3’), …])</p></li>
<li><p><strong>file_name</strong> – An optional filename that backs the returned
<a class="reference internal" href="#fanc.peaks.RaoPeakInfo" title="fanc.peaks.RaoPeakInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeakInfo</span></code></a> object</p></li>
<li><p><strong>intra_expected</strong> – A dict of the form
&lt;chromosome&gt;:&lt;list of expected values&gt; to override
expected value calculation</p></li>
<li><p><strong>inter_expected</strong> – A float describing the expected value
for inter-chromosomal contact matrix entries</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="#fanc.peaks.RaoPeakInfo" title="fanc.peaks.RaoPeakInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeakInfo</span></code></a> object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakCaller.e_d">
<em class="property">static </em><code class="sig-name descname">e_d</code><span class="sig-paren">(</span><em class="sig-param">m</em>, <em class="sig-param">i</em>, <em class="sig-param">j</em>, <em class="sig-param">e</em>, <em class="sig-param">w=1</em>, <em class="sig-param">p=0</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakCaller.e_d" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the average value of pixels in the “donut” neighborhood of a pixel.</p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakCaller.e_h">
<em class="property">static </em><code class="sig-name descname">e_h</code><span class="sig-paren">(</span><em class="sig-param">m</em>, <em class="sig-param">i</em>, <em class="sig-param">j</em>, <em class="sig-param">e</em>, <em class="sig-param">w=1</em>, <em class="sig-param">p=0</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakCaller.e_h" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the average value of pixels in the horizontal neighborhood of a pixel.</p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakCaller.e_ll">
<em class="property">static </em><code class="sig-name descname">e_ll</code><span class="sig-paren">(</span><em class="sig-param">m</em>, <em class="sig-param">i</em>, <em class="sig-param">j</em>, <em class="sig-param">e</em>, <em class="sig-param">w=1</em>, <em class="sig-param">p=0</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakCaller.e_ll" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the average value of pixels in the lower-left neighborhood of a pixel.</p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakCaller.e_v">
<em class="property">static </em><code class="sig-name descname">e_v</code><span class="sig-paren">(</span><em class="sig-param">m</em>, <em class="sig-param">i</em>, <em class="sig-param">j</em>, <em class="sig-param">e</em>, <em class="sig-param">w=1</em>, <em class="sig-param">p=0</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakCaller.e_v" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the average value of pixels in the vertical neighborhood of a pixel.</p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakCaller.find_chunk">
<em class="property">static </em><code class="sig-name descname">find_chunk</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">chunk_func=&lt;function RaoPeakCaller.&lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakCaller.find_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Use bisection to find a matching lambda chunk for a given expected value.</p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakCaller.ll_sum">
<em class="property">static </em><code class="sig-name descname">ll_sum</code><span class="sig-paren">(</span><em class="sig-param">m</em>, <em class="sig-param">i</em>, <em class="sig-param">j</em>, <em class="sig-param">w=1</em>, <em class="sig-param">p=0</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakCaller.ll_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum of pixels in the lower-left neighborhood of a pixel.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="fanc.peaks.RaoPeakFilter">
<em class="property">class </em><code class="sig-prename descclassname">fanc.peaks.</code><code class="sig-name descname">RaoPeakFilter</code><span class="sig-paren">(</span><em class="sig-param">mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fanc.peaks.PeakFilter" title="fanc.peaks.PeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">fanc.peaks.PeakFilter</span></code></a></p>
<p>Filter peaks exactly the same way that Rao et al. (2014) do.</p>
<p>It only retains peaks that</p>
<ol class="arabic simple">
<li><p>are at least 2-fold enriched over either the donut or lower-left neighborhood</p></li>
<li><p>are at least 1.5-fold enriched over the horizontal and vertical neighborhoods</p></li>
<li><p>are at least 1.75-fold enriched over both the donut and lower-left neighborhood</p></li>
<li><p>have an FDR &lt;= 0.1 in every neighborhood</p></li>
</ol>
<dl class="method">
<dt id="fanc.peaks.RaoPeakFilter.valid">
<code class="sig-name descname">valid</code><span class="sig-paren">(</span><em class="sig-param">row</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakFilter.valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Map valid_peak to MaskFilter.valid(self, row).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>row</strong> – A pytables Table row.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The boolean value returned by valid_edge.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakFilter.valid_peak">
<code class="sig-name descname">valid_peak</code><span class="sig-paren">(</span><em class="sig-param">peak</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakFilter.valid_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a <code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeak</span></code> object is valid or should
be filtered.</p>
<p>When implementing custom PeakFilter this method must be
overridden. It should return False for <code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeak</span></code> objects that
are to be fitered and True otherwise.</p>
<p>Internally, the <a class="reference internal" href="#fanc.peaks.RaoPeakInfo" title="fanc.peaks.RaoPeakInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeakInfo</span></code></a> object will iterate over all RaoPeak
instances to determine their validity on an individual
basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>peak</strong> – A <code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeak</span></code> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <a class="reference internal" href="#fanc.peaks.PeakFilter" title="fanc.peaks.PeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">PeakFilter</span></code></a> is valid, False otherwise</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="fanc.peaks.RaoPeakInfo">
<em class="property">class </em><code class="sig-prename descclassname">fanc.peaks.</code><code class="sig-name descname">RaoPeakInfo</code><span class="sig-paren">(</span><em class="sig-param">file_name=None</em>, <em class="sig-param">mode='a'</em>, <em class="sig-param">tmpdir=None</em>, <em class="sig-param">_table_name_regions='regions'</em>, <em class="sig-param">_table_name_peaks='edges'</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="matrix.html#fanc.matrix.RegionMatrixTable" title="fanc.matrix.RegionMatrixTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">fanc.matrix.RegionMatrixTable</span></code></a></p>
<p>Information about peaks called by <a class="reference internal" href="#fanc.peaks.RaoPeakCaller" title="fanc.peaks.RaoPeakCaller"><code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeakCaller</span></code></a>.</p>
<p>A peak has the following information:</p>
<p>source, sink: coordinates of the highest peak pixel in the Hi-C matrix
observed: observed value of the peak in the Hi-C matrix, generally uncorrected
e_ll: expected value of the peak given its lower-left neighborhood
e_h: expected value of the peak given its horizontal neighborhood
e_v: expected value of the peak given its vertical neighborhood
e_d: expected value of the peak given its surrounding (donut) neighborhood
e_ll_chunk: “lambda-chunk” this peak falls into given its ‘ll’ neighborhood
e_h_chunk: “lambda-chunk” this peak falls into given its ‘h’ neighborhood
e_v_chunk: “lambda-chunk” this peak falls into given its ‘v’ neighborhood
e_d_chunk: “lambda-chunk” this peak falls into given its ‘d’ neighborhood
fdr_ll: FDR of the peak given its lower-left neighborhood
fdr_h: FDR of the peak given its horizontal neighborhood
fdr_v: FDR of the peak given its vertical neighborhood
fdr_d: FDR of the peak given its surrounding (donut) neighborhood</p>
<p>For more information about neighborhoods and peak information,
see <a class="reference internal" href="#fanc.peaks.RaoPeakCaller" title="fanc.peaks.RaoPeakCaller"><code class="xref py py-class docutils literal notranslate"><span class="pre">RaoPeakCaller</span></code></a>.</p>
<dl class="class">
<dt id="fanc.peaks.RaoPeakInfo.ChromosomeDescription">
<em class="property">class </em><code class="sig-name descname">ChromosomeDescription</code><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.ChromosomeDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tables.description.IsDescription</span></code></p>
<p>Description of the chromosomes in this object.</p>
</dd></dl>

<dl class="class">
<dt id="fanc.peaks.RaoPeakInfo.MaskDescription">
<em class="property">class </em><code class="sig-name descname">MaskDescription</code><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.MaskDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tables.description.IsDescription</span></code></p>
</dd></dl>

<dl class="class">
<dt id="fanc.peaks.RaoPeakInfo.RegionDescription">
<em class="property">class </em><code class="sig-name descname">RegionDescription</code><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.RegionDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tables.description.IsDescription</span></code></p>
<p>Description of a genomic region for PyTables Table</p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.add_contact">
<code class="sig-name descname">add_contact</code><span class="sig-paren">(</span><em class="sig-param">contact</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.add_contact" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">add_edge()</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>contact</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code></p></li>
<li><p><strong>args</strong> – Positional arguments passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">_add_edge()</span></code></p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">_add_edge()</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.add_contacts">
<code class="sig-name descname">add_contacts</code><span class="sig-paren">(</span><em class="sig-param">contacts</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.add_contacts" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">add_edges()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.add_edge">
<code class="sig-name descname">add_edge</code><span class="sig-paren">(</span><em class="sig-param">edge</em>, <em class="sig-param">check_nodes_exist=True</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.add_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an edge / contact between two regions to this object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>edge</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code>, dict with at least the
attributes source and sink, optionally weight,
or a list of length 2 (source, sink) or 3
(source, sink, weight).</p></li>
<li><p><strong>check_nodes_exist</strong> – Make sure that there are nodes
that match source and sink indexes</p></li>
<li><p><strong>args</strong> – Positional arguments passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">_add_edge()</span></code></p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">_add_edge()</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.add_edge_from_dict">
<code class="sig-name descname">add_edge_from_dict</code><span class="sig-paren">(</span><em class="sig-param">edge</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.add_edge_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct method to add an edge from dict input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge</strong> – dict with at least the keys “source”
and “sink”. Additional keys will be loaded
as edge attributes</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.add_edge_from_edge">
<code class="sig-name descname">add_edge_from_edge</code><span class="sig-paren">(</span><em class="sig-param">edge</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.add_edge_from_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct method to add an edge from <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code> input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.add_edge_from_list">
<code class="sig-name descname">add_edge_from_list</code><span class="sig-paren">(</span><em class="sig-param">edge</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.add_edge_from_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct method to add an edge from list or tuple input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge</strong> – List or tuple. Should be of length 2
(source, sink) or 3 (source, sink, weight)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.add_edge_simple">
<code class="sig-name descname">add_edge_simple</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">sink</em>, <em class="sig-param">weight=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.add_edge_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct method to add an edge from <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code> input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source</strong> – Source region index</p></li>
<li><p><strong>sink</strong> – Sink region index</p></li>
<li><p><strong>weight</strong> – Weight of the edge</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.add_edges">
<code class="sig-name descname">add_edges</code><span class="sig-paren">(</span><em class="sig-param">edges</em>, <em class="sig-param">flush=True</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.add_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Bulk-add edges from a list.</p>
<p>List items can be any of the supported edge types,
list, tuple, dict, or <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code>. Repeatedly
calls <code class="xref py py-func docutils literal notranslate"><span class="pre">add_edge()</span></code>, so
may be inefficient for large amounts of data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edges</strong> – List (or iterator) of edges. See
<code class="xref py py-func docutils literal notranslate"><span class="pre">add_edge()</span></code>
for details</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.add_mask_description">
<code class="sig-name descname">add_mask_description</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">description</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.add_mask_description" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a mask description to the _mask table and return its ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – name of the mask</p></li>
<li><p><strong>description</strong> (<em>str</em>) – description of the mask</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>id of the mask</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.add_region">
<code class="sig-name descname">add_region</code><span class="sig-paren">(</span><em class="sig-param">region</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.add_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a genomic region to this object.</p>
<p>This method offers some flexibility in the types of objects
that can be loaded. See parameters for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>region</strong> – Can be a <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code>, a str in the form
‘&lt;chromosome&gt;:&lt;start&gt;-&lt;end&gt;[:&lt;strand&gt;], a dict with
at least the fields ‘chromosome’, ‘start’, and
‘end’, optionally ‘ix’, or a list of length 3
(chromosome, start, end) or 4 (ix, chromosome,
start, end).</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.add_regions">
<code class="sig-name descname">add_regions</code><span class="sig-paren">(</span><em class="sig-param">regions</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.add_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bulk insert multiple genomic regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>regions</strong> – List (or any iterator) with objects that
describe a genomic region. See
<code class="xref py py-class docutils literal notranslate"><span class="pre">add_region</span></code> for options.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.bin_intervals">
<em class="property">static </em><code class="sig-name descname">bin_intervals</code><span class="sig-paren">(</span><em class="sig-param">intervals</em>, <em class="sig-param">bins</em>, <em class="sig-param">interval_range=None</em>, <em class="sig-param">smoothing_window=None</em>, <em class="sig-param">nan_replacement=None</em>, <em class="sig-param">zero_to_nan=False</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.bin_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Bin a given set of intervals into a fixed number of bins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>intervals</strong> – iterator of tuples (start, end, score)</p></li>
<li><p><strong>bins</strong> – Number of bins to divide the region into</p></li>
<li><p><strong>interval_range</strong> – Optional. Tuple (start, end) in base pairs
of range of interval to be binned. Useful if
intervals argument does not cover to exact
genomic range to be binned.</p></li>
<li><p><strong>smoothing_window</strong> – Size of window (in bins) to smooth scores
over</p></li>
<li><p><strong>nan_replacement</strong> – NaN values in the scores will be replaced
with this value</p></li>
<li><p><strong>zero_to_nan</strong> – If True, will convert bins with score 0 to NaN</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>iterator of tuples: (start, end, score)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.bin_intervals_equidistant">
<em class="property">static </em><code class="sig-name descname">bin_intervals_equidistant</code><span class="sig-paren">(</span><em class="sig-param">intervals</em>, <em class="sig-param">bin_size</em>, <em class="sig-param">interval_range=None</em>, <em class="sig-param">smoothing_window=None</em>, <em class="sig-param">nan_replacement=None</em>, <em class="sig-param">zero_to_nan=False</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.bin_intervals_equidistant" title="Permalink to this definition">¶</a></dt>
<dd><p>Bin a given set of intervals into bins with a fixed size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>intervals</strong> – iterator of tuples (start, end, score)</p></li>
<li><p><strong>bin_size</strong> – Size of each bin in base pairs</p></li>
<li><p><strong>interval_range</strong> – Optional. Tuple (start, end) in base pairs
of range of interval to be binned. Useful if
intervals argument does not cover to exact
genomic range to be binned.</p></li>
<li><p><strong>smoothing_window</strong> – Size of window (in bins) to smooth scores
over</p></li>
<li><p><strong>nan_replacement</strong> – NaN values in the scores will be replaced
with this value</p></li>
<li><p><strong>zero_to_nan</strong> – If True, will convert bins with score 0 to NaN</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>iterator of tuples: (start, end, score)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.bin_size">
<em class="property">property </em><code class="sig-name descname">bin_size</code><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.bin_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the first region in the dataset.</p>
<p>Assumes all bins have equal size.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.binned_regions">
<code class="sig-name descname">binned_regions</code><span class="sig-paren">(</span><em class="sig-param">region=None</em>, <em class="sig-param">bins=None</em>, <em class="sig-param">bin_size=None</em>, <em class="sig-param">smoothing_window=None</em>, <em class="sig-param">nan_replacement=None</em>, <em class="sig-param">zero_to_nan=False</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.binned_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as region_intervals, but returns <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code>
objects instead of tuples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>region</strong> – String or class:<cite>~GenomicRegion</cite>
object denoting the region to be binned</p></li>
<li><p><strong>bins</strong> – Number of bins to divide the region into</p></li>
<li><p><strong>bin_size</strong> – Size of each bin (alternative to bins argument)</p></li>
<li><p><strong>smoothing_window</strong> – Size of window (in bins) to smooth scores
over</p></li>
<li><p><strong>nan_replacement</strong> – NaN values in the scores will be replaced
with this value</p></li>
<li><p><strong>zero_to_nan</strong> – If True, will convert bins with score 0 to NaN</p></li>
<li><p><strong>args</strong> – Arguments passed to _region_intervals</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to _region_intervals</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>iterator of <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code> objects</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.bins_to_distance">
<code class="sig-name descname">bins_to_distance</code><span class="sig-paren">(</span><em class="sig-param">bins</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.bins_to_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert fraction of bins to base pairs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>bins</strong> – float, fraction of bins</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>int, base pairs</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.chromosome_bins">
<em class="property">property </em><code class="sig-name descname">chromosome_bins</code><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.chromosome_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of chromosomes and the start
and end index of the bins they cover.</p>
<p>Returned list is range-compatible, i.e. chromosome
bins [0,5] cover chromosomes 1, 2, 3, and 4, not 5.</p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.chromosome_lengths">
<em class="property">property </em><code class="sig-name descname">chromosome_lengths</code><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.chromosome_lengths" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of chromosomes and their length
in bp.</p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.chromosomes">
<code class="sig-name descname">chromosomes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.chromosomes" title="Permalink to this definition">¶</a></dt>
<dd><p>List all chromosomes in this regions table.
:return: list of chromosome names.</p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><em class="sig-param">copy_tmp=True</em>, <em class="sig-param">remove_tmp=True</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close this HDF5 file and run exit operations.</p>
<p>If file was opened with tmpdir in read-only mode:
close file and delete temporary copy.</p>
<p>If file was opened with tmpdir in write or append mode:
Replace original file with copy and delete copy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>copy_tmp</strong> – If False, does not overwrite original with modified file.</p></li>
<li><p><strong>remove_tmp</strong> – If False, does not delete temporary copy of file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.distance_to_bins">
<code class="sig-name descname">distance_to_bins</code><span class="sig-paren">(</span><em class="sig-param">distance</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.distance_to_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert base pairs to fraction of bins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>distance</strong> – distance in base pairs</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>float, distance as fraction of bin size</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.downsample">
<code class="sig-name descname">downsample</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">file_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.downsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample edges from this object.</p>
<p>Sampling is always done on uncorrected Hi-C matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Sample size or reference object. If n &lt; 1 will be interpreted as
a fraction of total reads in this object.</p></li>
<li><p><strong>file_name</strong> – Output file name for down-sampled object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">RegionPairsTable</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.edge_data">
<code class="sig-name descname">edge_data</code><span class="sig-paren">(</span><em class="sig-param">attribute</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.edge_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over specific edge attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attribute</strong> – Name of the attribute, e.g. “weight”</p></li>
<li><p><strong>args</strong> – Positional arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>iterator over edge attribute</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.edge_subset">
<code class="sig-name descname">edge_subset</code><span class="sig-paren">(</span><em class="sig-param">key=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.edge_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a subset of edges.</p>
<p>This is an alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>generator (<code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.edges">
<em class="property">property </em><code class="sig-name descname">edges</code><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over contacts / edges.</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code> is the central function of
<code class="xref py py-class docutils literal notranslate"><span class="pre">RegionPairsContainer</span></code>. Here, we will use the
<code class="xref py py-class docutils literal notranslate"><span class="pre">Hic</span></code> implementation for demonstration purposes,
but the usage is exactly the same for all compatible
objects implementing <code class="xref py py-class docutils literal notranslate"><span class="pre">RegionPairsContainer</span></code>, including
<a class="reference internal" href="compatibility/juicer.html#fanc.compatibility.juicer.JuicerHic" title="fanc.compatibility.juicer.JuicerHic"><code class="xref py py-class docutils literal notranslate"><span class="pre">JuicerHic</span></code></a> and
<a class="reference internal" href="compatibility/cooler.html#fanc.compatibility.cooler.CoolerHic" title="fanc.compatibility.cooler.CoolerHic"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoolerHic</span></code></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">fanc</span>

<span class="c1"># file from FAN-C examples</span>
<span class="n">hic</span> <span class="o">=</span> <span class="n">fanc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;output/hic/binned/fanc_example_1mb.hic&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>We can easily find the number of edges in the sample
<code class="xref py py-class docutils literal notranslate"><span class="pre">Hic</span></code> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>  <span class="c1"># 8695</span>
</pre></div>
</div>
<p>When used in an iterator context, <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code>
iterates over all edges in the <code class="xref py py-class docutils literal notranslate"><span class="pre">RegionPairsContainer</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
    <span class="c1"># do something with edge</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="c1"># 42--42; bias: 5.797788472650082e-05; sink_node: chr18:42000001-43000000; source_node: chr18:42000001-43000000; weight: 0.12291311562018173</span>
    <span class="c1"># 24--28; bias: 6.496381719803623e-05; sink_node: chr18:28000001-29000000; source_node: chr18:24000001-25000000; weight: 0.025205961072838057</span>
    <span class="c1"># 5--76; bias: 0.00010230955745211447; sink_node: chr18:76000001-77000000; source_node: chr18:5000001-6000000; weight: 0.00961709840049876</span>
    <span class="c1"># 66--68; bias: 8.248432587969082e-05; sink_node: chr18:68000001-69000000; source_node: chr18:66000001-67000000; weight: 0.03876763316345468</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>Calling <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code> as a method has the
same effect:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># note the &#39;()&#39;</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
    <span class="c1"># do something with edge</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="c1"># 42--42; bias: 5.797788472650082e-05; sink_node: chr18:42000001-43000000; source_node: chr18:42000001-43000000; weight: 0.12291311562018173</span>
    <span class="c1"># 24--28; bias: 6.496381719803623e-05; sink_node: chr18:28000001-29000000; source_node: chr18:24000001-25000000; weight: 0.025205961072838057</span>
    <span class="c1"># 5--76; bias: 0.00010230955745211447; sink_node: chr18:76000001-77000000; source_node: chr18:5000001-6000000; weight: 0.00961709840049876</span>
    <span class="c1"># 66--68; bias: 8.248432587969082e-05; sink_node: chr18:68000001-69000000; source_node: chr18:66000001-67000000; weight: 0.03876763316345468</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>Rather than iterate over all edges in the object, we can select only a subset.
If the key is a string or a <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code>, all non-zero edges connecting
the region described by the key to any other region are returned. If the key is a
tuple of strings or <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code>, only edges between the two regions
are returned.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># select all edges between chromosome 19</span>
<span class="c1"># and any other region:</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="s2">&quot;chr19&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="c1"># 49--106; bias: 0.00026372303696871666; sink_node: chr19:27000001-28000000; source_node: chr18:49000001-50000000; weight: 0.003692122517562033</span>
    <span class="c1"># 6--82; bias: 0.00021923129703834945; sink_node: chr19:3000001-4000000; source_node: chr18:6000001-7000000; weight: 0.0008769251881533978</span>
    <span class="c1"># 47--107; bias: 0.00012820949175399097; sink_node: chr19:28000001-29000000; source_node: chr18:47000001-48000000; weight: 0.0015385139010478917</span>
    <span class="c1"># 38--112; bias: 0.0001493344481069762; sink_node: chr19:33000001-34000000; source_node: chr18:38000001-39000000; weight: 0.0005973377924279048</span>
    <span class="c1"># ...</span>

<span class="c1"># select all edges that are only on</span>
<span class="c1"># chromosome 19</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">((</span><span class="s1">&#39;chr19&#39;</span><span class="p">,</span> <span class="s1">&#39;chr19&#39;</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="c1"># 90--116; bias: 0.00021173151730025176; sink_node: chr19:37000001-38000000; source_node: chr19:11000001-12000000; weight: 0.009104455243910825</span>
    <span class="c1"># 135--135; bias: 0.00018003890596887822; sink_node: chr19:56000001-57000000; source_node: chr19:56000001-57000000; weight: 0.10028167062466517</span>
    <span class="c1"># 123--123; bias: 0.00011063368998965993; sink_node: chr19:44000001-45000000; source_node: chr19:44000001-45000000; weight: 0.1386240135570439</span>
    <span class="c1"># 92--93; bias: 0.00040851066434864896; sink_node: chr19:14000001-15000000; source_node: chr19:13000001-14000000; weight: 0.10090213409411629</span>
    <span class="c1"># ...</span>

<span class="c1"># select inter-chromosomal edges</span>
<span class="c1"># between chromosomes 18 and 19</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">((</span><span class="s1">&#39;chr18&#39;</span><span class="p">,</span> <span class="s1">&#39;chr19&#39;</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="c1"># 49--106; bias: 0.00026372303696871666; sink_node: chr19:27000001-28000000; source_node: chr18:49000001-50000000; weight: 0.003692122517562033</span>
    <span class="c1"># 6--82; bias: 0.00021923129703834945; sink_node: chr19:3000001-4000000; source_node: chr18:6000001-7000000; weight: 0.0008769251881533978</span>
    <span class="c1"># 47--107; bias: 0.00012820949175399097; sink_node: chr19:28000001-29000000; source_node: chr18:47000001-48000000; weight: 0.0015385139010478917</span>
    <span class="c1"># 38--112; bias: 0.0001493344481069762; sink_node: chr19:33000001-34000000; source_node: chr18:38000001-39000000; weight: 0.0005973377924279048</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>By default, <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code> will retrieve all edge attributes,
which can be slow when iterating over a lot of edges. This is why all file-based FAN-C
<code class="xref py py-class docutils literal notranslate"><span class="pre">RegionPairsContainer</span></code> objects support lazy loading, where attributes
are only read on demand.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="s1">&#39;chr18&#39;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">sink</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
    <span class="c1"># 42 42 0.12291311562018173 &lt;fanc.matrix.LazyEdge for row /edges/chrpair_0_0.row (Row), pointing to row #0&gt;</span>
    <span class="c1"># 24 28 0.025205961072838057 &lt;fanc.matrix.LazyEdge for row /edges/chrpair_0_0.row (Row), pointing to row #1&gt;</span>
    <span class="c1"># 5 76 0.00961709840049876 &lt;fanc.matrix.LazyEdge for row /edges/chrpair_0_0.row (Row), pointing to row #2&gt;</span>
    <span class="c1"># 66 68 0.03876763316345468 &lt;fanc.matrix.LazyEdge for row /edges/chrpair_0_0.row (Row), pointing to row #3&gt;</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The lazy iterator reuses the <code class="xref py py-class docutils literal notranslate"><span class="pre">LazyEdge</span></code> object in every iteration,
and overwrites the <code class="xref py py-class docutils literal notranslate"><span class="pre">LazyEdge</span></code> attributes. Therefore <strong>do not</strong> use
lazy iterators if you need to store edge objects for later access.
For example, the following code works as expected
<code class="code docutils literal notranslate"><span class="pre">list(hic.edges())</span></code>, with all <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code> objects stored in the
list, while this code <code class="code docutils literal notranslate"><span class="pre">list(hic.edges(lazy=True))</span></code>
will result in a list of identical <code class="xref py py-class docutils literal notranslate"><span class="pre">LazyEdge</span></code> objects. Always ensure
you do all edge processing in the loop when working with lazy iterators!</p>
</div>
<p>When working with normalised contact frequencies, such as obtained through
matrix balancing in the example above, <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code>
automatically returns normalised edge weights. In addition, the <code class="code docutils literal notranslate"><span class="pre">bias</span></code>
attribute will (typically) have a value different from 1.</p>
<p>When you are interested in the raw contact frequency, use the <code class="code docutils literal notranslate"><span class="pre">norm=False</span></code>
parameter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hic</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="s1">&#39;chr18&#39;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">sink</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
    <span class="c1"># 42 42 2120.0</span>
    <span class="c1"># 24 28 388.0</span>
    <span class="c1"># 5 76 94.0</span>
    <span class="c1"># 66 68 470.0</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>You can also choose to omit all intra- or inter-chromosomal edges using
<code class="code docutils literal notranslate"><span class="pre">intra_chromosomal=False</span></code> or <code class="code docutils literal notranslate"><span class="pre">inter_chromosomal=False</span></code>, respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Iterator over <code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code> or equivalent.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.edges_dict">
<code class="sig-name descname">edges_dict</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.edges_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Edges iterator with access by bracket notation.</p>
<p>This iterator <strong>always</strong> returns unnormalised edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dict or dict-like iterator</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.expected_values">
<code class="sig-name descname">expected_values</code><span class="sig-paren">(</span><em class="sig-param">selected_chromosome=None</em>, <em class="sig-param">norm=True</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.expected_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the expected values for genomic contacts at all distances.</p>
<p>This calculates the expected values between genomic regions
separated by a specific distance. Expected values are calculated
as the average weight of edges between region pairs with the same
genomic separation, taking into account unmappable regions.</p>
<p>It will return a tuple with three values: a list of genome-wide
intra-chromosomal expected values (list index corresponds to number
of separating bins), a dict with chromosome names as keys and
intra-chromosomal expected values specific to each chromosome, and
a float for inter-chromosomal expected value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>selected_chromosome</strong> – (optional) Chromosome name. If provided,
will only return expected values for this
chromosome.</p></li>
<li><p><strong>norm</strong> – If False, will calculate the expected values on the
unnormalised matrix.</p></li>
<li><p><strong>args</strong> – Not used in this context</p></li>
<li><p><strong>kwargs</strong> – Not used in this context</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of intra-chromosomal expected values,
dict of intra-chromosomal expected values by chromosome,
inter-chromosomal expected value</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.expected_values_and_marginals">
<code class="sig-name descname">expected_values_and_marginals</code><span class="sig-paren">(</span><em class="sig-param">selected_chromosome=None</em>, <em class="sig-param">norm=True</em>, <em class="sig-param">force=False</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.expected_values_and_marginals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the expected values for genomic contacts at all distances
and the whole matrix marginals.</p>
<p>This calculates the expected values between genomic regions
separated by a specific distance. Expected values are calculated
as the average weight of edges between region pairs with the same
genomic separation, taking into account unmappable regions.</p>
<p>It will return a tuple with three values: a list of genome-wide
intra-chromosomal expected values (list index corresponds to number
of separating bins), a dict with chromosome names as keys and
intra-chromosomal expected values specific to each chromosome, and
a float for inter-chromosomal expected value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>selected_chromosome</strong> – (optional) Chromosome name. If provided,
will only return expected values for this
chromosome.</p></li>
<li><p><strong>norm</strong> – If False, will calculate the expected values on the
unnormalised matrix.</p></li>
<li><p><strong>args</strong> – Not used in this context</p></li>
<li><p><strong>kwargs</strong> – Not used in this context</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of intra-chromosomal expected values,
dict of intra-chromosomal expected values by chromosome,
inter-chromosomal expected value</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.filter">
<code class="sig-name descname">filter</code><span class="sig-paren">(</span><em class="sig-param">edge_filter</em>, <em class="sig-param">queue=False</em>, <em class="sig-param">log_progress=True</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter edges in this object by using a
<code class="xref py py-class docutils literal notranslate"><span class="pre">MaskFilter</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>edge_filter</strong> – Class implementing <code class="xref py py-class docutils literal notranslate"><span class="pre">MaskFilter</span></code>.</p></li>
<li><p><strong>queue</strong> – If True, filter will be queued and can be executed
along with other queued filters using
<code class="xref py py-func docutils literal notranslate"><span class="pre">run_queued_filters()</span></code></p></li>
<li><p><strong>log_progress</strong> – If true, process iterating through all edges
will be continuously reported.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.filter_enrichment">
<code class="sig-name descname">filter_enrichment</code><span class="sig-paren">(</span><em class="sig-param">enrichment_ll_cutoff=1.0</em>, <em class="sig-param">enrichment_h_cutoff=1.0</em>, <em class="sig-param">enrichment_v_cutoff=1.0</em>, <em class="sig-param">enrichment_d_cutoff=1.0</em>, <em class="sig-param">queue=False</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.filter_enrichment" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function that applies a <code class="xref py py-class docutils literal notranslate"><span class="pre">ObservedExpectedRatioPeakFilter</span></code>.
The actual algorithm and rationale used for filtering will depend on the
internal _mapper attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>queue</strong> – If True, filter will be queued and can be executed
along with other queued filters using
run_queued_filters</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.filter_fdr">
<code class="sig-name descname">filter_fdr</code><span class="sig-paren">(</span><em class="sig-param">fdr_cutoff</em>, <em class="sig-param">queue=False</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.filter_fdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function that applies a <a class="reference internal" href="#fanc.peaks.FdrPeakFilter" title="fanc.peaks.FdrPeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">FdrPeakFilter</span></code></a>.
The actual algorithm and rationale used for filtering will depend on the
internal _mapper attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fdr_cutoff</strong> – The false-discovery rate of every neighborhood enrichment
must be lower or equal to this threshold</p></li>
<li><p><strong>queue</strong> – If True, filter will be queued and can be executed
along with other queued filters using
run_queued_filters</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.filter_mappability">
<code class="sig-name descname">filter_mappability</code><span class="sig-paren">(</span><em class="sig-param">cutoff</em>, <em class="sig-param">queue=False</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.filter_mappability" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function that applies a <a class="reference internal" href="#fanc.peaks.MappabilityPeakFilter" title="fanc.peaks.MappabilityPeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">MappabilityPeakFilter</span></code></a>.
The actual algorithm and rationale used for filtering will depend on the
internal _mapper attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cutoff</strong> – Minimum mappability (fraction of 1)</p></li>
<li><p><strong>queue</strong> – If True, filter will be queued and can be executed
along with other queued filters using
run_queued_filters</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.filter_observed">
<code class="sig-name descname">filter_observed</code><span class="sig-paren">(</span><em class="sig-param">cutoff</em>, <em class="sig-param">queue=False</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.filter_observed" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function that applies a <a class="reference internal" href="#fanc.peaks.ObservedPeakFilter" title="fanc.peaks.ObservedPeakFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">ObservedPeakFilter</span></code></a>.
The actual algorithm and rationale used for filtering will depend on the
internal _mapper attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cutoff</strong> – Minimum observed value</p></li>
<li><p><strong>queue</strong> – If True, filter will be queued and can be executed
along with other queued filters using
run_queued_filters</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.filter_rao">
<code class="sig-name descname">filter_rao</code><span class="sig-paren">(</span><em class="sig-param">queue=False</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.filter_rao" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function that applies all filters Rao et al. (2014) do.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>queue</strong> – If True, filter will be queued and can be executed
along with other queued filters using
run_queued_filters</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.find_region">
<code class="sig-name descname">find_region</code><span class="sig-paren">(</span><em class="sig-param">query_regions</em>, <em class="sig-param">_regions_dict=None</em>, <em class="sig-param">_region_ends=None</em>, <em class="sig-param">_chromosomes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.find_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the region that is at the center of a region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>query_regions</strong> – Region selector string, :class:~GenomicRegion, or
list of the former</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>index (or list of indexes) of the region at the center of the
query region</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.flush">
<code class="sig-name descname">flush</code><span class="sig-paren">(</span><em class="sig-param">silent=False</em>, <em class="sig-param">update_mappability=True</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to file and flush buffers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>silent</strong> – do not print flush progress</p></li>
<li><p><strong>update_mappability</strong> – After writing data, update mappability and expected values</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.get_mask">
<code class="sig-name descname">get_mask</code><span class="sig-paren">(</span><em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.get_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Search _mask table for key and return Mask.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> (<em>int</em>) – search by mask name</p></li>
<li><p><strong>key</strong> – search by mask ID</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Mask</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.get_masks">
<code class="sig-name descname">get_masks</code><span class="sig-paren">(</span><em class="sig-param">ix</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.get_masks" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract mask IDs encoded in parameter and return masks.</p>
<p>IDs are powers of 2, so a single int field in the table can hold
multiple masks by simply adding up the IDs. Similar principle to
UNIX chmod (although that uses base 8)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ix</strong> (<em>int</em>) – integer that is the sum of powers of 2. Note that this value
is not necessarily itself a power of 2.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of Masks extracted from ix</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list (Mask)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.intervals">
<code class="sig-name descname">intervals</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for region_intervals.</p>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.mappable">
<code class="sig-name descname">mappable</code><span class="sig-paren">(</span><em class="sig-param">region=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.mappable" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the mappability of regions in this object.</p>
<p>A “mappable” region has at least one contact to another region
in the genome.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">array</span></code> where True means mappable
and False unmappable</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.marginals">
<code class="sig-name descname">marginals</code><span class="sig-paren">(</span><em class="sig-param">masked=True</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.marginals" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the marginals vector of this Hic matrix.</p>
<p>Sums up all contacts for each bin of the Hi-C matrix.
Unmappable regoins will be masked in the returned vector unless
the <code class="code docutils literal notranslate"><span class="pre">masked</span></code> parameter is set to <code class="code docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>By default, corrected matrix entries are summed up.
To get uncorrected matrix marginals use <code class="code docutils literal notranslate"><span class="pre">norm=False</span></code>.
Generally, all parameters accepted by <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code>
are supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>masked</strong> – Use a numpy masked array to mask entries
corresponding to unmappable regions</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.matrix">
<code class="sig-name descname">matrix</code><span class="sig-paren">(</span><em class="sig-param">key=None</em>, <em class="sig-param">log=False</em>, <em class="sig-param">default_value=None</em>, <em class="sig-param">mask=True</em>, <em class="sig-param">log_base=2</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble a <code class="xref py py-class docutils literal notranslate"><span class="pre">RegionMatrix</span></code> from region pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> – Matrix selector. See <a class="reference internal" href="matrix.html#fanc.matrix.RegionPairsContainer.edges" title="fanc.matrix.RegionPairsContainer.edges"><code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></a>
for all supported key types</p></li>
<li><p><strong>log</strong> – If True, log-transform the matrix entries. Also see log_base</p></li>
<li><p><strong>log_base</strong> – Base of the log transformation. Default: 2; only used when
log=True</p></li>
<li><p><strong>default_value</strong> – (optional) set the default value of matrix entries
that have no associated edge/contact</p></li>
<li><p><strong>mask</strong> – If False, do not mask unmappable regions</p></li>
<li><p><strong>args</strong> – Positional arguments passed to
<a class="reference internal" href="matrix.html#fanc.matrix.RegionMatrixContainer.regions_and_matrix_entries" title="fanc.matrix.RegionMatrixContainer.regions_and_matrix_entries"><code class="xref py py-func docutils literal notranslate"><span class="pre">regions_and_matrix_entries()</span></code></a></p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to
<a class="reference internal" href="matrix.html#fanc.matrix.RegionMatrixContainer.regions_and_matrix_entries" title="fanc.matrix.RegionMatrixContainer.regions_and_matrix_entries"><code class="xref py py-func docutils literal notranslate"><span class="pre">regions_and_matrix_entries()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="matrix.html#fanc.matrix.RegionMatrix" title="fanc.matrix.RegionMatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegionMatrix</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.merge">
<em class="property">classmethod </em><code class="sig-name descname">merge</code><span class="sig-paren">(</span><em class="sig-param">matrices</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge multiple <code class="xref py py-class docutils literal notranslate"><span class="pre">RegionMatrixContainer</span></code> objects.</p>
<p>Merging is done by adding the weight of edges in each object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrices</strong> – list of <code class="xref py py-class docutils literal notranslate"><span class="pre">RegionMatrixContainer</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>merged <code class="xref py py-class docutils literal notranslate"><span class="pre">RegionMatrixContainer</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.merged_peaks">
<code class="sig-name descname">merged_peaks</code><span class="sig-paren">(</span><em class="sig-param">file_name=None</em>, <em class="sig-param">euclidian_distance=20000</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.merged_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge spatially proximal peaks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> – Optional file to save merged peak info to.</p></li>
<li><p><strong>euclidian_distance</strong> – Maximal distance in base pairs to still
consider two peaks to be the same</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="#fanc.peaks.PeakInfo" title="fanc.peaks.PeakInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">PeakInfo</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.possible_contacts">
<code class="sig-name descname">possible_contacts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.possible_contacts" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the possible number of contacts in the genome.</p>
<p>This calculates the number of potential region pairs in
a genome for any possible separation distance, taking into
account the existence of unmappable regions.</p>
<p>It will calculate one number for inter-chromosomal pairs,
return a list with the number of possible pairs where the
list index corresponds to the number of bins separating two regions,
and a dictionary of lists for each chromosome.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>possible intra-chromosomal pairs,
possible intra-chromosomal pairs by chromosome,
possible inter-chromosomal pairs</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.region_bins">
<code class="sig-name descname">region_bins</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.region_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>Return slice of start and end indices spanned by a region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>args</strong> – provide a <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code> here to get
the slice of start and end bins of onlythis region.
To get the slice over all regions leave this blank.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.region_data">
<code class="sig-name descname">region_data</code><span class="sig-paren">(</span><em class="sig-param">key</em>, <em class="sig-param">value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.region_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve or add vector-data to this object. If there is existing data in this
object with the same name, it will be replaced</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> – Name of the data column</p></li>
<li><p><strong>value</strong> – vector with region-based data (one entry per region)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.region_intervals">
<code class="sig-name descname">region_intervals</code><span class="sig-paren">(</span><em class="sig-param">region</em>, <em class="sig-param">bins=None</em>, <em class="sig-param">bin_size=None</em>, <em class="sig-param">smoothing_window=None</em>, <em class="sig-param">nan_replacement=None</em>, <em class="sig-param">zero_to_nan=False</em>, <em class="sig-param">score_field='score'</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.region_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return equally-sized genomic intervals and associated scores.</p>
<p>Use either bins or bin_size argument to control binning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>region</strong> – String or class:<cite>~GenomicRegion</cite>
object denoting the region to be binned</p></li>
<li><p><strong>bins</strong> – Number of bins to divide the region into</p></li>
<li><p><strong>bin_size</strong> – Size of each bin (alternative to bins argument)</p></li>
<li><p><strong>smoothing_window</strong> – Size of window (in bins) to smooth scores
over</p></li>
<li><p><strong>nan_replacement</strong> – NaN values in the scores will be replaced
with this value</p></li>
<li><p><strong>zero_to_nan</strong> – If True, will convert bins with score 0 to NaN</p></li>
<li><p><strong>args</strong> – Arguments passed to _region_intervals</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to _region_intervals</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>iterator of tuples: (start, end, score)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.region_subset">
<code class="sig-name descname">region_subset</code><span class="sig-paren">(</span><em class="sig-param">region</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.region_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a class:<cite>~GenomicRegion</cite> and returns all regions that
overlap with the supplied region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>region</strong> – String or class:<cite>~GenomicRegion</cite>
object for which covered bins will
be returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.regions">
<em class="property">property </em><code class="sig-name descname">regions</code><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over genomic regions in this object.</p>
<p>Will return a <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code> object in every iteration.
Can also be used to get the number of regions by calling
len() on the object returned by this method.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>RegionIter</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.regions_and_edges">
<code class="sig-name descname">regions_and_edges</code><span class="sig-paren">(</span><em class="sig-param">key</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.regions_and_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenient access to regions and edges selected by key.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> – Edge selector, see <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
<li><p><strong>args</strong> – Positional arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of row regions, list of col regions, iterator over edges</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.regions_and_matrix_entries">
<code class="sig-name descname">regions_and_matrix_entries</code><span class="sig-paren">(</span><em class="sig-param">key=None</em>, <em class="sig-param">score_field=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.regions_and_matrix_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenient access to non-zero matrix entries and associated regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> – Edge key, see <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
<li><p><strong>oe</strong> – If True, will divide observed values by their expected value
at the given distance. False by default</p></li>
<li><p><strong>oe_per_chromosome</strong> – If True (default), will do a per-chromosome O/E
calculation rather than using the whole matrix
to obtain expected values</p></li>
<li><p><strong>score_field</strong> – (optional) any edge attribute that returns a number
can be specified here for filling the matrix. Usually
this is defined by the <code class="code docutils literal notranslate"><span class="pre">_default_score_field</span></code>
attribute of the matrix class.</p></li>
<li><p><strong>args</strong> – Positional arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of row regions, list of col regions, iterator over (i, j, weight) tuples</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.regions_dict">
<em class="property">property </em><code class="sig-name descname">regions_dict</code><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.regions_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary with region index as keys
and regions as values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dict {region.ix: region, …}</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.regions_identical">
<em class="property">static </em><code class="sig-name descname">regions_identical</code><span class="sig-paren">(</span><em class="sig-param">pairs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.regions_identical" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the regions in all objects in the list are identical.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pairs</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">RegionBased</span></code>
objects</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if chromosome, start, and end are identical between
all regions in the same list positions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.run_queued_filters">
<code class="sig-name descname">run_queued_filters</code><span class="sig-paren">(</span><em class="sig-param">log_progress=True</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.run_queued_filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Run queued filters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>log_progress</strong> – If true, process iterating through all edges
will be continuously reported.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.scaling_factor">
<code class="sig-name descname">scaling_factor</code><span class="sig-paren">(</span><em class="sig-param">matrix</em>, <em class="sig-param">weight_column=None</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.scaling_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the scaling factor to another matrix.</p>
<p>Calculates the ratio between the number of contacts in
this Hic object to the number of contacts in another
Hic object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> – A <code class="xref py py-class docutils literal notranslate"><span class="pre">Hic</span></code> object</p></li>
<li><p><strong>weight_column</strong> – Name of the column to calculate the scaling factor on</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.subset">
<code class="sig-name descname">subset</code><span class="sig-paren">(</span><em class="sig-param">*regions</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Subset a Hic object by specifying one or more subset regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>regions</strong> – string or GenomicRegion object(s)</p></li>
<li><p><strong>kwargs</strong> – Supports
file_name: destination file name of subset Hic object;
tmpdir: if True works in tmp until object is closed
additional parameters are passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">edges()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Hic</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.to_bed">
<code class="sig-name descname">to_bed</code><span class="sig-paren">(</span><em class="sig-param">file_name</em>, <em class="sig-param">subset=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.to_bed" title="Permalink to this definition">¶</a></dt>
<dd><p>Export regions as BED file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> – Path of file to write regions to</p></li>
<li><p><strong>subset</strong> – optional <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code> or str to
write only regions overlapping this region</p></li>
<li><p><strong>kwargs</strong> – Passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">write_bed()</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.to_bigwig">
<code class="sig-name descname">to_bigwig</code><span class="sig-paren">(</span><em class="sig-param">file_name</em>, <em class="sig-param">subset=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.to_bigwig" title="Permalink to this definition">¶</a></dt>
<dd><p>Export regions as BigWig file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> – Path of file to write regions to</p></li>
<li><p><strong>subset</strong> – optional <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code> or str to
write only regions overlapping this region</p></li>
<li><p><strong>kwargs</strong> – Passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">write_bigwig()</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="fanc.peaks.RaoPeakInfo.to_gff">
<code class="sig-name descname">to_gff</code><span class="sig-paren">(</span><em class="sig-param">file_name</em>, <em class="sig-param">subset=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.RaoPeakInfo.to_gff" title="Permalink to this definition">¶</a></dt>
<dd><p>Export regions as GFF file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> – Path of file to write regions to</p></li>
<li><p><strong>subset</strong> – optional <code class="xref py py-class docutils literal notranslate"><span class="pre">GenomicRegion</span></code> or str to
write only regions overlapping this region</p></li>
<li><p><strong>kwargs</strong> – Passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">write_gff()</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="fanc.peaks.overlap_peaks">
<code class="sig-prename descclassname">fanc.peaks.</code><code class="sig-name descname">overlap_peaks</code><span class="sig-paren">(</span><em class="sig-param">peaks</em>, <em class="sig-param">max_distance=6000</em><span class="sig-paren">)</span><a class="headerlink" href="#fanc.peaks.overlap_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate overlap between different peak calls.</p>
<p>Useful for comparing peak calls across different samples
or conditions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>peaks</strong> (<em>dict</em>) – Peaks to overlap. Dictionary of
<code class="xref py py-class docutils literal notranslate"><span class="pre">fanc.data.network.PeakInfo</span></code>,
keys are dataset names.</p></li>
<li><p><strong>max_distance</strong> (<em>int</em>) – Maximum distance between peaks for overlap</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>DataFrame of overlap statistics and dictionary
containing overlapping peaks. Keys are sets
of dataset names.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(pandas.DataFrame, fanc.data.network.PeakInfo)</p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="compatibility.html" class="btn btn-neutral float-right" title="FAN-C compatibility modules" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="hic.html" class="btn btn-neutral float-left" title="Hic module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Kai Kruse, Vaquerizas lab

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>